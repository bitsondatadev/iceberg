[{"id":0,"href":"/docs/0.13.0/java-api-quickstart/","title":"Java Quickstart","section":"API","content":"Java API Quickstart #  Create a table #  Tables are created using either a Catalog or an implementation of the Tables interface.\nUsing a Hive catalog #  The Hive catalog connects to a Hive metastore to keep track of Iceberg tables. You can initialize a Hive catalog with a name and some properties. (see: Catalog properties)\nNote: Currently, setConf is always required for hive catalogs, but this will change in the future.\nimport org.apache.iceberg.hive.HiveCatalog; Catalog catalog = new HiveCatalog(); catalog.setConf(spark.sparkContext().hadoopConfiguration()); // Configure using Spark\u0026#39;s Hadoop configuration  Map \u0026lt;String, String\u0026gt; properties = new HashMap\u0026lt;String, String\u0026gt;(); properties.put(\u0026#34;warehouse\u0026#34;, \u0026#34;...\u0026#34;); properties.put(\u0026#34;uri\u0026#34;, \u0026#34;...\u0026#34;); catalog.initialize(\u0026#34;hive\u0026#34;, properties); The Catalog interface defines methods for working with tables, like createTable, loadTable, renameTable, and dropTable.\nTo create a table, pass an Identifier and a Schema along with other initial metadata:\nimport org.apache.iceberg.Table; import org.apache.iceberg.catalog.TableIdentifier; TableIdentifier name = TableIdentifier.of(\u0026#34;logging\u0026#34;, \u0026#34;logs\u0026#34;); Table table = catalog.createTable(name, schema, spec); // or to load an existing table, use the following line // Table table = catalog.loadTable(name); The logs schema and partition spec are created below.\nUsing a Hadoop catalog #  A Hadoop catalog doesn\u0026rsquo;t need to connect to a Hive MetaStore, but can only be used with HDFS or similar file systems that support atomic rename. Concurrent writes with a Hadoop catalog are not safe with a local FS or S3. To create a Hadoop catalog:\nimport org.apache.hadoop.conf.Configuration; import org.apache.iceberg.hadoop.HadoopCatalog; Configuration conf = new Configuration(); String warehousePath = \u0026#34;hdfs://host:8020/warehouse_path\u0026#34;; HadoopCatalog catalog = new HadoopCatalog(conf, warehousePath); Like the Hive catalog, HadoopCatalog implements Catalog, so it also has methods for working with tables, like createTable, loadTable, and dropTable.\nThis example creates a table with Hadoop catalog:\nimport org.apache.iceberg.Table; import org.apache.iceberg.catalog.TableIdentifier; TableIdentifier name = TableIdentifier.of(\u0026#34;logging\u0026#34;, \u0026#34;logs\u0026#34;); Table table = catalog.createTable(name, schema, spec); // or to load an existing table, use the following line // Table table = catalog.loadTable(name); The logs schema and partition spec are created below.\nUsing Hadoop tables #  Iceberg also supports tables that are stored in a directory in HDFS. Concurrent writes with a Hadoop tables are not safe when stored in the local FS or S3. Directory tables don\u0026rsquo;t support all catalog operations, like rename, so they use the Tables interface instead of Catalog.\nTo create a table in HDFS, use HadoopTables:\nimport org.apache.hadoop.conf.Configuration; import org.apache.iceberg.hadoop.HadoopTables; import org.apache.iceberg.Table; Configuration conf = new Configuration(); HadoopTables tables = new HadoopTables(conf); Table table = tables.create(schema, spec, table_location); // or to load an existing table, use the following line // Table table = tables.load(table_location); Hadoop tables shouldn\u0026rsquo;t be used with file systems that do not support atomic rename. Iceberg relies on rename to synchronize concurrent commits for directory tables.  Tables in Spark #  Spark uses both HiveCatalog and HadoopTables to load tables. Hive is used when the identifier passed to load or save is not a path, otherwise Spark assumes it is a path-based table.\nTo read and write to tables from Spark see:\n SQL queries in Spark INSERT INTO in Spark MERGE INTO in Spark  Schemas #  Create a schema #  This example creates a schema for a logs table:\nimport org.apache.iceberg.Schema; import org.apache.iceberg.types.Types; Schema schema = new Schema( Types.NestedField.required(1, \u0026#34;level\u0026#34;, Types.StringType.get()), Types.NestedField.required(2, \u0026#34;event_time\u0026#34;, Types.TimestampType.withZone()), Types.NestedField.required(3, \u0026#34;message\u0026#34;, Types.StringType.get()), Types.NestedField.optional(4, \u0026#34;call_stack\u0026#34;, Types.ListType.ofRequired(5, Types.StringType.get())) ); When using the Iceberg API directly, type IDs are required. Conversions from other schema formats, like Spark, Avro, and Parquet will automatically assign new IDs.\nWhen a table is created, all IDs in the schema are re-assigned to ensure uniqueness.\nConvert a schema from Avro #  To create an Iceberg schema from an existing Avro schema, use converters in AvroSchemaUtil:\nimport org.apache.avro.Schema; import org.apache.avro.Schema.Parser; import org.apache.iceberg.avro.AvroSchemaUtil; Schema avroSchema = new Parser().parse(\u0026#34;{\\\u0026#34;type\\\u0026#34;: \\\u0026#34;record\\\u0026#34; , ... }\u0026#34;); Schema icebergSchema = AvroSchemaUtil.toIceberg(avroSchema); Convert a schema from Spark #  To create an Iceberg schema from an existing table, use converters in SparkSchemaUtil:\nimport org.apache.iceberg.spark.SparkSchemaUtil; Schema schema = SparkSchemaUtil.schemaForTable(sparkSession, table_name); Partitioning #  Create a partition spec #  Partition specs describe how Iceberg should group records into data files. Partition specs are created for a table\u0026rsquo;s schema using a builder.\nThis example creates a partition spec for the logs table that partitions records by the hour of the log event\u0026rsquo;s timestamp and by log level:\nimport org.apache.iceberg.PartitionSpec; PartitionSpec spec = PartitionSpec.builderFor(schema) .hour(\u0026#34;event_time\u0026#34;) .identity(\u0026#34;level\u0026#34;) .build(); For more information on the different partition transforms that Iceberg offers, visit this page.\n"},{"id":1,"href":"/docs/0.13.0/docs/asf/license/","title":"License","section":"ASF","content":"  "},{"id":2,"href":"/docs/0.13.0/getting-started/","title":"Getting Started","section":"Spark","content":"Getting Started #  The latest version of Iceberg is 0.13.0.\nSpark is currently the most feature-rich compute engine for Iceberg operations. We recommend you to get started with Spark to understand Iceberg concepts and features with examples. You can also view documentations of using Iceberg with other compute engine under the Engines tab.\nUsing Iceberg in Spark 3 #  To use Iceberg in a Spark shell, use the --packages option:\nspark-shell --packages org.apache.iceberg:iceberg-spark3-runtime:0.13.0 If you want to include Iceberg in your Spark installation, add the [iceberg-spark3-runtime Jar][spark-runtime-jar] to Spark\u0026rsquo;s jars folder.  Adding catalogs #  Iceberg comes with catalogs that enable SQL commands to manage tables and load them by name. Catalogs are configured using properties under spark.sql.catalog.(catalog_name).\nThis command creates a path-based catalog named local for tables under $PWD/warehouse and adds support for Iceberg tables to Spark\u0026rsquo;s built-in catalog:\nspark-sql --packages org.apache.iceberg:iceberg-spark3-runtime:0.13.0\\  --conf spark.sql.extensions=org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions \\  --conf spark.sql.catalog.spark_catalog=org.apache.iceberg.spark.SparkSessionCatalog \\  --conf spark.sql.catalog.spark_catalog.type=hive \\  --conf spark.sql.catalog.local=org.apache.iceberg.spark.SparkCatalog \\  --conf spark.sql.catalog.local.type=hadoop \\  --conf spark.sql.catalog.local.warehouse=$PWD/warehouse Creating a table #  To create your first Iceberg table in Spark, use the spark-sql shell or spark.sql(...) to run a CREATE TABLE command:\n-- local is the path-based catalog defined above CREATE TABLE local.db.table (id bigint, data string) USING iceberg Iceberg catalogs support the full range of SQL DDL commands, including:\n CREATE TABLE ... PARTITIONED BY CREATE TABLE ... AS SELECT ALTER TABLE DROP TABLE  Writing #  Once your table is created, insert data using INSERT INTO:\nINSERT INTO local.db.table VALUES (1, \u0026#39;a\u0026#39;), (2, \u0026#39;b\u0026#39;), (3, \u0026#39;c\u0026#39;); INSERT INTO local.db.table SELECT id, data FROM source WHERE length(data) = 1; Iceberg also adds row-level SQL updates to Spark, MERGE INTO and DELETE FROM:\nMERGE INTO local.db.target t USING (SELECT * FROM updates) u ON t.id = u.id WHEN MATCHED THEN UPDATE SET t.count = t.count + u.count WHEN NOT MATCHED THEN INSERT * Iceberg supports writing DataFrames using the new v2 DataFrame write API:\nspark.table(\u0026#34;source\u0026#34;).select(\u0026#34;id\u0026#34;, \u0026#34;data\u0026#34;) .writeTo(\u0026#34;local.db.table\u0026#34;).append() The old write API is supported, but not recommended.\nReading #  To read with SQL, use the an Iceberg table name in a SELECT query:\nSELECT count(1) as count, data FROM local.db.table GROUP BY data SQL is also the recommended way to inspect tables. To view all of the snapshots in a table, use the snapshots metadata table:\nSELECT * FROM local.db.table.snapshots +-------------------------+----------------+-----------+-----------+----------------------------------------------------+-----+ | committed_at | snapshot_id | parent_id | operation | manifest_list | ... | +-------------------------+----------------+-----------+-----------+----------------------------------------------------+-----+ | 2019-02-08 03:29:51.215 | 57897183625154 | null | append | s3://.../table/metadata/snap-57897183625154-1.avro | ... | | | | | | | ... | | | | | | | ... | | ... | ... | ... | ... | ... | ... | +-------------------------+----------------+-----------+-----------+----------------------------------------------------+-----+ DataFrame reads are supported and can now reference tables by name using spark.table:\nval df = spark.table(\u0026#34;local.db.table\u0026#34;) df.count() Next steps #  Next, you can learn more about Iceberg tables in Spark:\n DDL commands: CREATE, ALTER, and DROP Querying data: SELECT queries and metadata tables Writing data: INSERT INTO and MERGE INTO Maintaining tables with stored procedures  "},{"id":3,"href":"/docs/0.13.0/api/","title":"Java API","section":"API","content":"Iceberg Java API #  Tables #  The main purpose of the Iceberg API is to manage table metadata, like schema, partition spec, metadata, and data files that store table data.\nTable metadata and operations are accessed through the Table interface. This interface will return table information.\nTable metadata #  The Table interface provides access to the table metadata:\n schema returns the current table schema spec returns the current table partition spec properties returns a map of key-value properties currentSnapshot returns the current table snapshot snapshots returns all valid snapshots for the table snapshot(id) returns a specific snapshot by ID location returns the table\u0026rsquo;s base location  Tables also provide refresh to update the table to the latest version, and expose helpers:\n io returns the FileIO used to read and write table files locationProvider returns a LocationProvider used to create paths for data and metadata files  Scanning #  File level #  Iceberg table scans start by creating a TableScan object with newScan.\nTableScan scan = table.newScan(); To configure a scan, call filter and select on the TableScan to get a new TableScan with those changes.\nTableScan filteredScan = scan.filter(Expressions.equal(\u0026#34;id\u0026#34;, 5)) Calls to configuration methods create a new TableScan so that each TableScan is immutable and won\u0026rsquo;t change unexpectedly if shared across threads.\nWhen a scan is configured, planFiles, planTasks, and schema are used to return files, tasks, and the read projection.\nTableScan scan = table.newScan() .filter(Expressions.equal(\u0026#34;id\u0026#34;, 5)) .select(\u0026#34;id\u0026#34;, \u0026#34;data\u0026#34;); Schema projection = scan.schema(); Iterable\u0026lt;CombinedScanTask\u0026gt; tasks = scan.planTasks(); Use asOfTime or useSnapshot to configure the table snapshot for time travel queries.\nRow level #  Iceberg table scans start by creating a ScanBuilder object with IcebergGenerics.read.\nScanBuilder scanBuilder = IcebergGenerics.read(table) To configure a scan, call where and select on the ScanBuilder to get a new ScanBuilder with those changes.\nscanBuilder.where(Expressions.equal(\u0026#34;id\u0026#34;, 5)) When a scan is configured, call method build to execute scan. build return CloseableIterable\u0026lt;Record\u0026gt;\nCloseableIterable\u0026lt;Record\u0026gt; result = IcebergGenerics.read(table) .where(Expressions.lessThan(\u0026#34;id\u0026#34;, 5)) .build(); where Record is Iceberg record for iceberg-data module org.apache.iceberg.data.Record.\nUpdate operations #  Table also exposes operations that update the table. These operations use a builder pattern, PendingUpdate, that commits when PendingUpdate#commit is called.\nFor example, updating the table schema is done by calling updateSchema, adding updates to the builder, and finally calling commit to commit the pending changes to the table:\ntable.updateSchema() .addColumn(\u0026#34;count\u0026#34;, Types.LongType.get()) .commit(); Available operations to update a table are:\n updateSchema \u0026ndash; update the table schema updateProperties \u0026ndash; update table properties updateLocation \u0026ndash; update the table\u0026rsquo;s base location newAppend \u0026ndash; used to append data files newFastAppend \u0026ndash; used to append data files, will not compact metadata newOverwrite \u0026ndash; used to append data files and remove files that are overwritten newDelete \u0026ndash; used to delete data files newRewrite \u0026ndash; used to rewrite data files; will replace existing files with new versions newTransaction \u0026ndash; create a new table-level transaction rewriteManifests \u0026ndash; rewrite manifest data by clustering files, for faster scan planning rollback \u0026ndash; rollback the table state to a specific snapshot  Transactions #  Transactions are used to commit multiple table changes in a single atomic operation. A transaction is used to create individual operations using factory methods, like newAppend, just like working with a Table. Operations created by a transaction are committed as a group when commitTransaction is called.\nFor example, deleting and appending a file in the same transaction:\nTransaction t = table.newTransaction(); // commit operations to the transaction t.newDelete().deleteFromRowFilter(filter).commit(); t.newAppend().appendFile(data).commit(); // commit all the changes to the table t.commitTransaction(); Types #  Iceberg data types are located in the org.apache.iceberg.types package.\nPrimitives #  Primitive type instances are available from static methods in each type class. Types without parameters use get, and types like decimal use factory methods:\nTypes.IntegerType.get() // int Types.DoubleType.get() // double Types.DecimalType.of(9, 2) // decimal(9, 2) Nested types #  Structs, maps, and lists are created using factory methods in type classes.\nLike struct fields, map keys or values and list elements are tracked as nested fields. Nested fields track field IDs and nullability.\nStruct fields are created using NestedField.optional or NestedField.required. Map value and list element nullability is set in the map and list factory methods.\n// struct\u0026lt;1 id: int, 2 data: optional string\u0026gt; StructType struct = Struct.of( Types.NestedField.required(1, \u0026#34;id\u0026#34;, Types.IntegerType.get()), Types.NestedField.optional(2, \u0026#34;data\u0026#34;, Types.StringType.get()) ) // map\u0026lt;1 key: int, 2 value: optional string\u0026gt; MapType map = MapType.ofOptional( 1, 2, Types.IntegerType.get(), Types.StringType.get() ) // array\u0026lt;1 element: int\u0026gt; ListType list = ListType.ofRequired(1, IntegerType.get()); Expressions #  Iceberg\u0026rsquo;s expressions are used to configure table scans. To create expressions, use the factory methods in Expressions.\nSupported predicate expressions are:\n isNull notNull equal notEqual lessThan lessThanOrEqual greaterThan greaterThanOrEqual in notIn startsWith notStartsWith  Supported expression operations are:\n and or not  Constant expressions are:\n alwaysTrue alwaysFalse  Expression binding #  When created, expressions are unbound. Before an expression is used, it will be bound to a data type to find the field ID the expression name represents, and to convert predicate literals.\nFor example, before using the expression lessThan(\u0026quot;x\u0026quot;, 10), Iceberg needs to determine which column \u0026quot;x\u0026quot; refers to and convert 10 to that column\u0026rsquo;s data type.\nIf the expression could be bound to the type struct\u0026lt;1 x: long, 2 y: long\u0026gt; or to struct\u0026lt;11 x: int, 12 y: int\u0026gt;.\nExpression example #  table.newScan() .filter(Expressions.greaterThanOrEqual(\u0026#34;x\u0026#34;, 5)) .filter(Expressions.lessThan(\u0026#34;x\u0026#34;, 10)) Modules #  Iceberg table support is organized in library modules:\n iceberg-common contains utility classes used in other modules iceberg-api contains the public Iceberg API, including expressions, types, tables, and operations iceberg-arrow is an implementation of the Iceberg type system for reading and writing data stored in Iceberg tables using Apache Arrow as the in-memory data format iceberg-aws contains implementations of the Iceberg API to be used with tables stored on AWS S3 and/or for tables defined using the AWS Glue data catalog iceberg-core contains implementations of the Iceberg API and support for Avro data files, this is what processing engines should depend on iceberg-parquet is an optional module for working with tables backed by Parquet files iceberg-orc is an optional module for working with tables backed by ORC files (experimental) iceberg-hive-metastore is an implementation of Iceberg tables backed by the Hive metastore Thrift client  This project Iceberg also has modules for adding Iceberg support to processing engines and associated tooling:\n iceberg-spark2 is an implementation of Spark\u0026rsquo;s Datasource V2 API in 2.4 for Iceberg (use iceberg-spark-runtime for a shaded version) iceberg-spark3 is an implementation of Spark\u0026rsquo;s Datasource V2 API in 3.0 for Iceberg (use iceberg-spark3-runtime for a shaded version) iceberg-flink is an implementation of Flink\u0026rsquo;s Table and DataStream API for Iceberg (use iceberg-flink-runtime for a shaded version) iceberg-hive3 is an implementation of Hive 3 specific SerDe\u0026rsquo;s for Timestamp, TimestampWithZone, and Date object inspectors (use iceberg-hive-runtime for a shaded version). iceberg-mr is an implementation of MapReduce and Hive InputFormats and SerDes for Iceberg (use iceberg-hive-runtime for a shaded version for use with Hive) iceberg-nessie is a module used to integrate Iceberg table metadata history and operations with Project Nessie iceberg-data is a client library used to read Iceberg tables from JVM applications iceberg-pig is an implementation of Pig\u0026rsquo;s LoadFunc API for Iceberg iceberg-runtime generates a shaded runtime jar for Spark to integrate with iceberg tables  "},{"id":4,"href":"/docs/0.13.0/docs/asf/security/","title":"Security","section":"ASF","content":"  "},{"id":5,"href":"/docs/0.13.0/flink/","title":"Getting Started","section":"Flink","content":"Flink #  Apache Iceberg supports both Apache Flink\u0026rsquo;s DataStream API and Table API. Currently, Iceberg integration for Apache Flink is available for Flink versions 1.12, 1.13, and 1.14. Previous versions of Iceberg also support Flink 1.11.\n   Feature support Flink Notes     SQL create catalog ✔️    SQL create database ✔️    SQL create table ✔️    SQL create table like ✔️    SQL alter table ✔️ Only support altering table properties, column and partition changes are not supported   SQL drop_table ✔️    SQL select ✔️ Support both streaming and batch mode   SQL insert into ✔️ ️ Support both streaming and batch mode   SQL insert overwrite ✔️ ️    DataStream read ✔️ ️    DataStream append ✔️ ️    DataStream overwrite ✔️ ️    Metadata tables ️ Support Java API but does not support Flink SQL   Rewrite files action ✔️ ️     Preparation when using Flink SQL Client #  To create iceberg table in flink, we recommend to use Flink SQL Client because it\u0026rsquo;s easier for users to understand the concepts.\nStep.1 Downloading the flink 1.11.x binary package from the apache flink download page. We now use scala 2.12 to archive the apache iceberg-flink-runtime jar, so it\u0026rsquo;s recommended to use flink 1.11 bundled with scala 2.12.\nFLINK_VERSION=1.11.1 SCALA_VERSION=2.12 APACHE_FLINK_URL=archive.apache.org/dist/flink/ wget ${APACHE_FLINK_URL}/flink-${FLINK_VERSION}/flink-${FLINK_VERSION}-bin-scala_${SCALA_VERSION}.tgz tar xzvf flink-${FLINK_VERSION}-bin-scala_${SCALA_VERSION}.tgz Step.2 Start a standalone flink cluster within hadoop environment.\n# HADOOP_HOME is your hadoop root directory after unpack the binary package. export HADOOP_CLASSPATH=`$HADOOP_HOME/bin/hadoop classpath` # Start the flink standalone cluster ./bin/start-cluster.sh Step.3 Start the flink SQL client.\nWe\u0026rsquo;ve created a separate flink-runtime module in iceberg project to generate a bundled jar, which could be loaded by flink SQL client directly.\nIf we want to build the flink-runtime bundled jar manually, please just build the iceberg project and it will generate the jar under \u0026lt;iceberg-root-dir\u0026gt;/flink-runtime/build/libs. Of course, we could also download the flink-runtime jar from the apache official repository.\n# HADOOP_HOME is your hadoop root directory after unpack the binary package. export HADOOP_CLASSPATH=`$HADOOP_HOME/bin/hadoop classpath` ./bin/sql-client.sh embedded -j \u0026lt;flink-runtime-directory\u0026gt;/iceberg-flink-runtime-xxx.jar shell By default, iceberg has included hadoop jars for hadoop catalog. If we want to use hive catalog, we will need to load the hive jars when opening the flink sql client. Fortunately, apache flink has provided a bundled hive jar for sql client. So we could open the sql client as the following:\n# HADOOP_HOME is your hadoop root directory after unpack the binary package. export HADOOP_CLASSPATH=`$HADOOP_HOME/bin/hadoop classpath` # download Iceberg dependency ICEBERG_VERSION=0.11.1 MAVEN_URL=https://repo1.maven.org/maven2 ICEBERG_MAVEN_URL=${MAVEN_URL}/org/apache/iceberg ICEBERG_PACKAGE=iceberg-flink-runtime wget ${ICEBERG_MAVEN_URL}/${ICEBERG_PACKAGE}/${ICEBERG_VERSION}/${ICEBERG_PACKAGE}-${ICEBERG_VERSION}.jar # download the flink-sql-connector-hive-${HIVE_VERSION}_${SCALA_VERSION}-${FLINK_VERSION}.jar HIVE_VERSION=2.3.6 SCALA_VERSION=2.11 FLINK_VERSION=1.11.0 FLINK_CONNECTOR_URL=${MAVEN_URL}/org/apache/flink FLINK_CONNECTOR_PACKAGE=flink-sql-connector-hive wget ${FLINK_CONNECTOR_URL}/${FLINK_CONNECTOR_PACKAGE}-${HIVE_VERSION}_${SCALA_VERSION}/${FLINK_VERSION}/${FLINK_CONNECTOR_PACKAGE}-${HIVE_VERSION}_${SCALA_VERSION}-${FLINK_VERSION}.jar # open the SQL client. /path/to/bin/sql-client.sh embedded \\  -j ${ICEBERG_PACKAGE}-${ICEBERG_VERSION}.jar \\  -j ${FLINK_CONNECTOR_PACKAGE}-${HIVE_VERSION}_${SCALA_VERSION}-${FLINK_VERSION}.jar \\  shell Preparation when using Flink\u0026rsquo;s Python API #  Install the Apache Flink dependency using pip\npip install apache-flink==1.11.1 In order for pyflink to function properly, it needs to have access to all Hadoop jars. For pyflink we need to copy those Hadoop jars to the installation directory of pyflink, which can be found under \u0026lt;PYTHON_ENV_INSTALL_DIR\u0026gt;/site-packages/pyflink/lib/ (see also a mention of this on the Flink ML). We can use the following short Python script to copy all Hadoop jars (you need to make sure that HADOOP_HOME points to your Hadoop installation):\nimport os import shutil import site def copy_all_hadoop_jars_to_pyflink(): if not os.getenv(\u0026#34;HADOOP_HOME\u0026#34;): raise Exception(\u0026#34;The HADOOP_HOME env var must be set and point to a valid Hadoop installation\u0026#34;) jar_files = [] def find_pyflink_lib_dir(): for dir in site.getsitepackages(): package_dir = os.path.join(dir, \u0026#34;pyflink\u0026#34;, \u0026#34;lib\u0026#34;) if os.path.exists(package_dir): return package_dir return None for root, _, files in os.walk(os.getenv(\u0026#34;HADOOP_HOME\u0026#34;)): for file in files: if file.endswith(\u0026#34;.jar\u0026#34;): jar_files.append(os.path.join(root, file)) pyflink_lib_dir = find_pyflink_lib_dir() num_jar_files = len(jar_files) print(f\u0026#34;Copying {num_jar_files}Hadoop jar files to pyflink\u0026#39;s lib directory at {pyflink_lib_dir}\u0026#34;) for jar in jar_files: shutil.copy(jar, pyflink_lib_dir) if __name__ == \u0026#39;__main__\u0026#39;: copy_all_hadoop_jars_to_pyflink() Once the script finished, you should see output similar to\nCopying 645 Hadoop jar files to pyflink's lib directory at \u0026lt;PYTHON_DIR\u0026gt;/lib/python3.8/site-packages/pyflink/lib Now we need to provide a file:// path to the iceberg-flink-runtime jar, which we can either get by building the project and looking at \u0026lt;iceberg-root-dir\u0026gt;/flink-runtime/build/libs, or downloading it from the Apache official repository. Third-party libs can be added to pyflink via env.add_jars(\u0026quot;file:///my/jar/path/connector.jar\u0026quot;) / table_env.get_config().get_configuration().set_string(\u0026quot;pipeline.jars\u0026quot;, \u0026quot;file:///my/jar/path/connector.jar\u0026quot;), which is also mentioned in the official docs. In our example we\u0026rsquo;re using env.add_jars(..) as shown below:\nimport os from pyflink.datastream import StreamExecutionEnvironment env = StreamExecutionEnvironment.get_execution_environment() iceberg_flink_runtime_jar = os.path.join(os.getcwd(), \u0026#34;iceberg-flink-runtime-0.13.0.jar\u0026#34;) env.add_jars(\u0026#34;file://{}\u0026#34;.format(iceberg_flink_runtime_jar)) Once we reached this point, we can then create a StreamTableEnvironment and execute Flink SQL statements. The below example shows how to create a custom catalog via the Python Table API:\nfrom pyflink.table import StreamTableEnvironment table_env = StreamTableEnvironment.create(env) table_env.execute_sql(\u0026#34;CREATE CATALOG my_catalog WITH (\u0026#34; \u0026#34;\u0026#39;type\u0026#39;=\u0026#39;iceberg\u0026#39;, \u0026#34; \u0026#34;\u0026#39;catalog-impl\u0026#39;=\u0026#39;com.my.custom.CatalogImpl\u0026#39;, \u0026#34; \u0026#34;\u0026#39;my-additional-catalog-config\u0026#39;=\u0026#39;my-value\u0026#39;)\u0026#34;) For more details, please refer to the Python Table API.\nCreating catalogs and using catalogs. #  Flink 1.11 support to create catalogs by using flink sql.\nCatalog Configuration #  A catalog is created and named by executing the following query (replace \u0026lt;catalog_name\u0026gt; with your catalog name and \u0026lt;config_key\u0026gt;=\u0026lt;config_value\u0026gt; with catalog implementation config):\nCREATE CATALOG \u0026lt;catalog_name\u0026gt; WITH ( \u0026#39;type\u0026#39;=\u0026#39;iceberg\u0026#39;, `\u0026lt;config_key\u0026gt;`=`\u0026lt;config_value\u0026gt;` ); The following properties can be set globally and are not limited to a specific catalog implementation:\n type: Must be iceberg. (required) catalog-type: hive or hadoop for built-in catalogs, or left unset for custom catalog implementations using catalog-impl. (Optional) catalog-impl: The fully-qualified class name custom catalog implementation, must be set if catalog-type is unset. (Optional) property-version: Version number to describe the property version. This property can be used for backwards compatibility in case the property format changes. The current property version is 1. (Optional) cache-enabled: Whether to enable catalog cache, default value is true  Hive catalog #  This creates an iceberg catalog named hive_catalog that can be configured using 'catalog-type'='hive', which loads tables from a hive metastore:\nCREATE CATALOG hive_catalog WITH ( \u0026#39;type\u0026#39;=\u0026#39;iceberg\u0026#39;, \u0026#39;catalog-type\u0026#39;=\u0026#39;hive\u0026#39;, \u0026#39;uri\u0026#39;=\u0026#39;thrift://localhost:9083\u0026#39;, \u0026#39;clients\u0026#39;=\u0026#39;5\u0026#39;, \u0026#39;property-version\u0026#39;=\u0026#39;1\u0026#39;, \u0026#39;warehouse\u0026#39;=\u0026#39;hdfs://nn:8020/warehouse/path\u0026#39; ); The following properties can be set if using the Hive catalog:\n uri: The Hive metastore\u0026rsquo;s thrift URI. (Required) clients: The Hive metastore client pool size, default value is 2. (Optional) warehouse: The Hive warehouse location, users should specify this path if neither set the hive-conf-dir to specify a location containing a hive-site.xml configuration file nor add a correct hive-site.xml to classpath. hive-conf-dir: Path to a directory containing a hive-site.xml configuration file which will be used to provide custom Hive configuration values. The value of hive.metastore.warehouse.dir from \u0026lt;hive-conf-dir\u0026gt;/hive-site.xml (or hive configure file from classpath) will be overwrote with the warehouse value if setting both hive-conf-dir and warehouse when creating iceberg catalog.  Hadoop catalog #  Iceberg also supports a directory-based catalog in HDFS that can be configured using 'catalog-type'='hadoop':\nCREATE CATALOG hadoop_catalog WITH ( \u0026#39;type\u0026#39;=\u0026#39;iceberg\u0026#39;, \u0026#39;catalog-type\u0026#39;=\u0026#39;hadoop\u0026#39;, \u0026#39;warehouse\u0026#39;=\u0026#39;hdfs://nn:8020/warehouse/path\u0026#39;, \u0026#39;property-version\u0026#39;=\u0026#39;1\u0026#39; ); The following properties can be set if using the Hadoop catalog:\n warehouse: The HDFS directory to store metadata files and data files. (Required)  We could execute the sql command USE CATALOG hive_catalog to set the current catalog.\nCustom catalog #  Flink also supports loading a custom Iceberg Catalog implementation by specifying the catalog-impl property. Here is an example:\nCREATE CATALOG my_catalog WITH ( \u0026#39;type\u0026#39;=\u0026#39;iceberg\u0026#39;, \u0026#39;catalog-impl\u0026#39;=\u0026#39;com.my.custom.CatalogImpl\u0026#39;, \u0026#39;my-additional-catalog-config\u0026#39;=\u0026#39;my-value\u0026#39; ); Create through YAML config #  Catalogs can be registered in sql-client-defaults.yaml before starting the SQL client. Here is an example:\ncatalogs: - name: my_catalog type: iceberg catalog-type: hadoop warehouse: hdfs://nn:8020/warehouse/path DDL commands #  CREATE DATABASE #  By default, iceberg will use the default database in flink. Using the following example to create a separate database if we don\u0026rsquo;t want to create tables under the default database:\nCREATE DATABASE iceberg_db; USE iceberg_db; CREATE TABLE #  CREATE TABLE `hive_catalog`.`default`.`sample` ( id BIGINT COMMENT \u0026#39;unique id\u0026#39;, data STRING ); Table create commands support the most commonly used flink create clauses now, including:\n PARTITION BY (column1, column2, ...) to configure partitioning, apache flink does not yet support hidden partitioning. COMMENT 'table document' to set a table description. WITH ('key'='value', ...) to set table configuration which will be stored in apache iceberg table properties.  Currently, it does not support computed column, primary key and watermark definition etc.\nPARTITIONED BY #  To create a partition table, use PARTITIONED BY:\nCREATE TABLE `hive_catalog`.`default`.`sample` ( id BIGINT COMMENT \u0026#39;unique id\u0026#39;, data STRING ) PARTITIONED BY (data); Apache Iceberg support hidden partition but apache flink don\u0026rsquo;t support partitioning by a function on columns, so we\u0026rsquo;ve no way to support hidden partition in flink DDL now, we will improve apache flink DDL in future.\nCREATE TABLE LIKE #  To create a table with the same schema, partitioning, and table properties as another table, use CREATE TABLE LIKE.\nCREATE TABLE `hive_catalog`.`default`.`sample` ( id BIGINT COMMENT \u0026#39;unique id\u0026#39;, data STRING ); CREATE TABLE `hive_catalog`.`default`.`sample_like` LIKE `hive_catalog`.`default`.`sample`; For more details, refer to the Flink CREATE TABLE documentation.\nALTER TABLE #  Iceberg only support altering table properties in flink 1.11 now.\nALTER TABLE `hive_catalog`.`default`.`sample` SET (\u0026#39;write.format.default\u0026#39;=\u0026#39;avro\u0026#39;) ALTER TABLE .. RENAME TO #  ALTER TABLE `hive_catalog`.`default`.`sample` RENAME TO `hive_catalog`.`default`.`new_sample`; DROP TABLE #  To delete a table, run:\nDROP TABLE `hive_catalog`.`default`.`sample`; Querying with SQL #  Iceberg support both streaming and batch read in flink now. we could execute the following sql command to switch the execute type from \u0026lsquo;streaming\u0026rsquo; mode to \u0026lsquo;batch\u0026rsquo; mode, and vice versa:\n-- Execute the flink job in streaming mode for current session context SET execution.type = streaming -- Execute the flink job in batch mode for current session context SET execution.type = batch Flink batch read #  If want to check all the rows in iceberg table by submitting a flink batch job, you could execute the following sentences:\n-- Execute the flink job in batch mode for current session context SET execution.type = batch ; SELECT * FROM sample ; Flink streaming read #  Iceberg supports processing incremental data in flink streaming jobs which starts from a historical snapshot-id:\n-- Submit the flink job in streaming mode for current session. SET execution.type = streaming ; -- Enable this switch because streaming read SQL will provide few job options in flink SQL hint options. SET table.dynamic-table-options.enabled=true; -- Read all the records from the iceberg current snapshot, and then read incremental data starting from that snapshot. SELECT * FROM sample /*+ OPTIONS(\u0026#39;streaming\u0026#39;=\u0026#39;true\u0026#39;, \u0026#39;monitor-interval\u0026#39;=\u0026#39;1s\u0026#39;)*/ ; -- Read all incremental data starting from the snapshot-id \u0026#39;3821550127947089987\u0026#39; (records from this snapshot will be excluded). SELECT * FROM sample /*+ OPTIONS(\u0026#39;streaming\u0026#39;=\u0026#39;true\u0026#39;, \u0026#39;monitor-interval\u0026#39;=\u0026#39;1s\u0026#39;, \u0026#39;start-snapshot-id\u0026#39;=\u0026#39;3821550127947089987\u0026#39;)*/ ; Those are the options that could be set in flink SQL hint options for streaming job:\n monitor-interval: time interval for consecutively monitoring newly committed data files (default value: \u0026lsquo;1s\u0026rsquo;). start-snapshot-id: the snapshot id that streaming job starts from.  Writing with SQL #  Iceberg support both INSERT INTO and INSERT OVERWRITE in flink 1.11 now.\nINSERT INTO #  To append new data to a table with a flink streaming job, use INSERT INTO:\nINSERT INTO `hive_catalog`.`default`.`sample` VALUES (1, \u0026#39;a\u0026#39;); INSERT INTO `hive_catalog`.`default`.`sample` SELECT id, data from other_kafka_table; INSERT OVERWRITE #  To replace data in the table with the result of a query, use INSERT OVERWRITE in batch job (flink streaming job does not support INSERT OVERWRITE). Overwrites are atomic operations for Iceberg tables.\nPartitions that have rows produced by the SELECT query will be replaced, for example:\nINSERT OVERWRITE sample VALUES (1, \u0026#39;a\u0026#39;); Iceberg also support overwriting given partitions by the select values:\nINSERT OVERWRITE `hive_catalog`.`default`.`sample` PARTITION(data=\u0026#39;a\u0026#39;) SELECT 6; For a partitioned iceberg table, when all the partition columns are set a value in PARTITION clause, it is inserting into a static partition, otherwise if partial partition columns (prefix part of all partition columns) are set a value in PARTITION clause, it is writing the query result into a dynamic partition. For an unpartitioned iceberg table, its data will be completely overwritten by INSERT OVERWRITE.\nReading with DataStream #  Iceberg support streaming or batch read in Java API now.\nBatch Read #  This example will read all records from iceberg table and then print to the stdout console in flink batch job:\nStreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment(); TableLoader tableLoader = TableLoader.fromHadoopTable(\u0026#34;hdfs://nn:8020/warehouse/path\u0026#34;); DataStream\u0026lt;RowData\u0026gt; batch = FlinkSource.forRowData() .env(env) .tableLoader(tableLoader) .streaming(false) .build(); // Print all records to stdout. batch.print(); // Submit and execute this batch read job. env.execute(\u0026#34;Test Iceberg Batch Read\u0026#34;); Streaming read #  This example will read incremental records which start from snapshot-id \u0026lsquo;3821550127947089987\u0026rsquo; and print to stdout console in flink streaming job:\nStreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment(); TableLoader tableLoader = TableLoader.fromHadoopTable(\u0026#34;hdfs://nn:8020/warehouse/path\u0026#34;); DataStream\u0026lt;RowData\u0026gt; stream = FlinkSource.forRowData() .env(env) .tableLoader(tableLoader) .streaming(true) .startSnapshotId(3821550127947089987L) .build(); // Print all records to stdout. stream.print(); // Submit and execute this streaming read job. env.execute(\u0026#34;Test Iceberg Streaming Read\u0026#34;); There are other options that we could set by Java API, please see the FlinkSource#Builder.\nWriting with DataStream #  Iceberg support writing to iceberg table from different DataStream input.\nAppending data. #  we have supported writing DataStream\u0026lt;RowData\u0026gt; and DataStream\u0026lt;Row\u0026gt; to the sink iceberg table natively.\nStreamExecutionEnvironment env = ...; DataStream\u0026lt;RowData\u0026gt; input = ... ; Configuration hadoopConf = new Configuration(); TableLoader tableLoader = TableLoader.fromHadoopTable(\u0026#34;hdfs://nn:8020/warehouse/path\u0026#34;, hadoopConf); FlinkSink.forRowData(input) .tableLoader(tableLoader) .build(); env.execute(\u0026#34;Test Iceberg DataStream\u0026#34;); The iceberg API also allows users to write generic DataStream\u0026lt;T\u0026gt; to iceberg table, more example could be found in this unit test.\nOverwrite data #  To overwrite the data in existing iceberg table dynamically, we could set the overwrite flag in FlinkSink builder.\nStreamExecutionEnvironment env = ...; DataStream\u0026lt;RowData\u0026gt; input = ... ; Configuration hadoopConf = new Configuration(); TableLoader tableLoader = TableLoader.fromHadoopTable(\u0026#34;hdfs://nn:8020/warehouse/path\u0026#34;, hadoopConf); FlinkSink.forRowData(input) .tableLoader(tableLoader) .overwrite(true) .build(); env.execute(\u0026#34;Test Iceberg DataStream\u0026#34;); Inspecting tables. #  Iceberg does not support inspecting table in flink sql now, we need to use iceberg\u0026rsquo;s Java API to read iceberg\u0026rsquo;s meta data to get those table information.\nRewrite files action. #  Iceberg provides API to rewrite small files into large files by submitting flink batch job. The behavior of this flink action is the same as the spark\u0026rsquo;s rewriteDataFiles.\nimport org.apache.iceberg.flink.actions.Actions; TableLoader tableLoader = TableLoader.fromHadoopTable(\u0026#34;hdfs://nn:8020/warehouse/path\u0026#34;); Table table = tableLoader.loadTable(); RewriteDataFilesActionResult result = Actions.forTable(table) .rewriteDataFiles() .execute(); For more doc about options of the rewrite files action, please see RewriteDataFilesAction\nFuture improvement. #  There are some features that we do not yet support in the current flink iceberg integration work:\n Don\u0026rsquo;t support creating iceberg table with hidden partitioning. Discussion in flink mail list. Don\u0026rsquo;t support creating iceberg table with computed column. Don\u0026rsquo;t support creating iceberg table with watermark. Don\u0026rsquo;t support adding columns, removing columns, renaming columns, changing columns. FLINK-19062 is tracking this.  "},{"id":6,"href":"/docs/0.13.0/custom-catalog/","title":"Java Custom Catalog","section":"API","content":"Custom Catalog Implementation #  It\u0026rsquo;s possible to read an iceberg table either from an hdfs path or from a hive table. It\u0026rsquo;s also possible to use a custom metastore in place of hive. The steps to do that are as follows.\n Custom TableOperations Custom Catalog Custom FileIO Custom LocationProvider Custom IcebergSource  Custom table operations implementation #  Extend BaseMetastoreTableOperations to provide implementation on how to read and write metadata\nExample:\nclass CustomTableOperations extends BaseMetastoreTableOperations { private String dbName; private String tableName; private Configuration conf; private FileIO fileIO; protected CustomTableOperations(Configuration conf, String dbName, String tableName) { this.conf = conf; this.dbName = dbName; this.tableName = tableName; } // The doRefresh method should provide implementation on how to get the metadata location  @Override public void doRefresh() { // Example custom service which returns the metadata location given a dbName and tableName  String metadataLocation = CustomService.getMetadataForTable(conf, dbName, tableName); // When updating from a metadata file location, call the helper method  refreshFromMetadataLocation(metadataLocation); } // The doCommit method should provide implementation on how to update with metadata location atomically  @Override public void doCommit(TableMetadata base, TableMetadata metadata) { String oldMetadataLocation = base.location(); // Write new metadata using helper method  String newMetadataLocation = writeNewMetadata(metadata, currentVersion() + 1); // Example custom service which updates the metadata location for the given db and table atomically  CustomService.updateMetadataLocation(dbName, tableName, oldMetadataLocation, newMetadataLocation); } // The io method provides a FileIO which is used to read and write the table metadata files  @Override public FileIO io() { if (fileIO == null) { fileIO = new HadoopFileIO(conf); } return fileIO; } } A TableOperations instance is usually obtained by calling Catalog.newTableOps(TableIdentifier). See the next section about implementing and loading a custom catalog.\nCustom catalog implementation #  Extend BaseMetastoreCatalog to provide default warehouse locations and instantiate CustomTableOperations\nExample:\npublic class CustomCatalog extends BaseMetastoreCatalog { private Configuration configuration; // must have a no-arg constructor to be dynamically loaded  // initialize(String name, Map\u0026lt;String, String\u0026gt; properties) will be called to complete initialization  public CustomCatalog() { } public CustomCatalog(Configuration configuration) { this.configuration = configuration; } @Override protected TableOperations newTableOps(TableIdentifier tableIdentifier) { String dbName = tableIdentifier.namespace().level(0); String tableName = tableIdentifier.name(); // instantiate the CustomTableOperations  return new CustomTableOperations(configuration, dbName, tableName); } @Override protected String defaultWarehouseLocation(TableIdentifier tableIdentifier) { // Can choose to use any other configuration name  String tableLocation = configuration.get(\u0026#34;custom.iceberg.warehouse.location\u0026#34;); // Can be an s3 or hdfs path  if (tableLocation == null) { throw new RuntimeException(\u0026#34;custom.iceberg.warehouse.location configuration not set!\u0026#34;); } return String.format( \u0026#34;%s/%s.db/%s\u0026#34;, tableLocation, tableIdentifier.namespace().levels()[0], tableIdentifier.name()); } @Override public boolean dropTable(TableIdentifier identifier, boolean purge) { // Example service to delete table  CustomService.deleteTable(identifier.namepsace().level(0), identifier.name()); } @Override public void renameTable(TableIdentifier from, TableIdentifier to) { Preconditions.checkArgument(from.namespace().level(0).equals(to.namespace().level(0)), \u0026#34;Cannot move table between databases\u0026#34;); // Example service to rename table  CustomService.renameTable(from.namepsace().level(0), from.name(), to.name()); } // implement this method to read catalog name and properties during initialization  public void initialize(String name, Map\u0026lt;String, String\u0026gt; properties) { } } Catalog implementations can be dynamically loaded in most compute engines. For Spark and Flink, you can specify the catalog-impl catalog property to load it. Read the Configuration section for more details. For MapReduce, implement org.apache.iceberg.mr.CatalogLoader and set Hadoop property iceberg.mr.catalog.loader.class to load it. If your catalog must read Hadoop configuration to access certain environment properties, make your catalog implement org.apache.hadoop.conf.Configurable.\nCustom file IO implementation #  Extend FileIO and provide implementation to read and write data files\nExample:\npublic class CustomFileIO implements FileIO { // must have a no-arg constructor to be dynamically loaded  // initialize(Map\u0026lt;String, String\u0026gt; properties) will be called to complete initialization  public CustomFileIO() { } @Override public InputFile newInputFile(String s) { // you also need to implement the InputFile interface for a custom input file  return new CustomInputFile(s); } @Override public OutputFile newOutputFile(String s) { // you also need to implement the OutputFile interface for a custom output file  return new CustomOutputFile(s); } @Override public void deleteFile(String path) { Path toDelete = new Path(path); FileSystem fs = Util.getFs(toDelete); try { fs.delete(toDelete, false /* not recursive */); } catch (IOException e) { throw new RuntimeIOException(e, \u0026#34;Failed to delete file: %s\u0026#34;, path); } } // implement this method to read catalog properties during initialization  public void initialize(Map\u0026lt;String, String\u0026gt; properties) { } } If you are already implementing your own catalog, you can implement TableOperations.io() to use your custom FileIO. In addition, custom FileIO implementations can also be dynamically loaded in HadoopCatalog and HiveCatalog by specifying the io-impl catalog property. Read the Configuration section for more details. If your FileIO must read Hadoop configuration to access certain environment properties, make your FileIO implement org.apache.hadoop.conf.Configurable.\nCustom location provider implementation #  Extend LocationProvider and provide implementation to determine the file path to write data\nExample:\npublic class CustomLocationProvider implements LocationProvider { private String tableLocation; // must have a 2-arg constructor like this, or a no-arg constructor  public CustomLocationProvider(String tableLocation, Map\u0026lt;String, String\u0026gt; properties) { this.tableLocation = tableLocation; } @Override public String newDataLocation(String filename) { // can use any custom method to generate a file path given a file name  return String.format(\u0026#34;%s/%s/%s\u0026#34;, tableLocation, UUID.randomUUID().toString(), filename); } @Override public String newDataLocation(PartitionSpec spec, StructLike partitionData, String filename) { // can use any custom method to generate a file path given a partition info and file name  return newDataLocation(filename); } } If you are already implementing your own catalog, you can override TableOperations.locationProvider() to use your custom default LocationProvider. To use a different custom location provider for a specific table, specify the implementation when creating the table using table property write.location-provider.impl\nExample:\nCREATE TABLE hive.default.my_table ( id bigint, data string, category string) USING iceberg OPTIONS ( \u0026#39;write.location-provider.impl\u0026#39;=\u0026#39;com.my.CustomLocationProvider\u0026#39; ) PARTITIONED BY (category); Custom IcebergSource #  Extend IcebergSource and provide implementation to read from CustomCatalog\nExample:\npublic class CustomIcebergSource extends IcebergSource { @Override protected Table findTable(DataSourceOptions options, Configuration conf) { Optional\u0026lt;String\u0026gt; path = options.get(\u0026#34;path\u0026#34;); Preconditions.checkArgument(path.isPresent(), \u0026#34;Cannot open table: path is not set\u0026#34;); // Read table from CustomCatalog  CustomCatalog catalog = new CustomCatalog(conf); TableIdentifier tableIdentifier = TableIdentifier.parse(path.get()); return catalog.loadTable(tableIdentifier); } } Register the CustomIcebergSource by updating META-INF/services/org.apache.spark.sql.sources.DataSourceRegister with its fully qualified name\n"},{"id":7,"href":"/docs/0.13.0/docs/asf/sponsors/","title":"Sponsors","section":"ASF","content":"  "},{"id":8,"href":"/docs/0.13.0/hive/","title":"Hive","section":"Docs","content":"Hive #  Iceberg supports reading and writing Iceberg tables through Hive by using a StorageHandler. Here is the current compatibility matrix for Iceberg Hive support:\n   Feature Hive 2.x Hive 3.1.2     CREATE EXTERNAL TABLE ✔️ ✔️   CREATE TABLE ✔️ ✔️   DROP TABLE ✔️ ✔️   SELECT ✔️ (MapReduce and Tez) ✔️ (MapReduce and Tez)   INSERT INTO ✔️ (MapReduce only)️ ✔️ (MapReduce only)    Enabling Iceberg support in Hive #  Loading runtime jar #  To enable Iceberg support in Hive, the HiveIcebergStorageHandler and supporting classes need to be made available on Hive\u0026rsquo;s classpath. These are provided by the iceberg-hive-runtime jar file. For example, if using the Hive shell, this can be achieved by issuing a statement like so:\nadd jar /path/to/iceberg-hive-runtime.jar; There are many others ways to achieve this including adding the jar file to Hive\u0026rsquo;s auxiliary classpath so it is available by default. Please refer to Hive\u0026rsquo;s documentation for more information.\nEnabling support #  If the Iceberg storage handler is not in Hive\u0026rsquo;s classpath, then Hive cannot load or update the metadata for an Iceberg table when the storage handler is set. To avoid the appearance of broken tables in Hive, Iceberg will not add the storage handler to a table unless Hive support is enabled. The storage handler is kept in sync (added or removed) every time Hive engine support for the table is updated, i.e. turned on or off in the table properties. There are two ways to enable Hive support: globally in Hadoop Configuration and per-table using a table property.\nHadoop configuration #  To enable Hive support globally for an application, set iceberg.engine.hive.enabled=true in its Hadoop configuration. For example, setting this in the hive-site.xml loaded by Spark will enable the storage handler for all tables created by Spark.\nStarting with Apache Iceberg 0.11.0, when using Hive with Tez you also have to disable vectorization (hive.vectorized.execution.enabled=false).  Table property configuration #  Alternatively, the property engine.hive.enabled can be set to true and added to the table properties when creating the Iceberg table. Here is an example of doing it programmatically:\nCatalog catalog = ...; Map\u0026lt;String, String\u0026gt; tableProperties = Maps.newHashMap(); tableProperties.put(TableProperties.ENGINE_HIVE_ENABLED, \u0026#34;true\u0026#34;); // engine.hive.enabled=true catalog.createTable(tableId, schema, spec, tableProperties); The table level configuration overrides the global Hadoop configuration.\nHive on Tez configuration #  To use the Tez engine on Hive 3.1.2 or later, Tez needs to be upgraded to \u0026gt;= 0.10.1 which contains a necessary fix Tez-4248.\nTo use the Tez engine on Hive 2.3.x, you will need to manually build Tez from the branch-0.9 branch due to a backwards incompatibility issue with Tez 0.10.1.\nYou will also need to set the following property in the Hive configuration: tez.mrreader.config.update.properties=hive.io.file.readcolumn.names,hive.io.file.readcolumn.ids.\nCatalog Management #  Global Hive catalog #  From the Hive engine\u0026rsquo;s perspective, there is only one global data catalog that is defined in the Hadoop configuration in the runtime environment. In contrast, Iceberg supports multiple different data catalog types such as Hive, Hadoop, AWS Glue, or custom catalog implementations. Iceberg also allows loading a table directly based on its path in the file system. Those tables do not belong to any catalog. Users might want to read these cross-catalog and path-based tables through the Hive engine for use cases like join.\nTo support this, a table in the Hive metastore can represent three different ways of loading an Iceberg table, depending on the table\u0026rsquo;s iceberg.catalog property:\n The table will be loaded using a HiveCatalog that corresponds to the metastore configured in the Hive environment if no iceberg.catalog is set The table will be loaded using a custom catalog if iceberg.catalog is set to a catalog name (see below) The table can be loaded directly using the table\u0026rsquo;s root location if iceberg.catalog is set to location_based_table  For cases 2 and 3 above, users can create an overlay of an Iceberg table in the Hive metastore, so that different table types can work together in the same Hive environment. See CREATE EXTERNAL TABLE and CREATE TABLE for more details.\nCustom Iceberg catalogs #  To globally register different catalogs, set the following Hadoop configurations:\n   Config Key Description     iceberg.catalog.\u0026lt;catalog_name\u0026gt;.type type of catalog: hive, hadoop, or left unset if using a custom catalog   iceberg.catalog.\u0026lt;catalog_name\u0026gt;.catalog-impl catalog implementation, must not be null if type is empty   iceberg.catalog.\u0026lt;catalog_name\u0026gt;.\u0026lt;key\u0026gt; any config key and value pairs for the catalog    Here are some examples using Hive CLI:\nRegister a HiveCatalog called another_hive:\nSET iceberg.catalog.another_hive.type=hive; SET iceberg.catalog.another_hive.uri=thrift://example.com:9083; SET iceberg.catalog.another_hive.clients=10; SET iceberg.catalog.another_hive.warehouse=hdfs://example.com:8020/warehouse; Register a HadoopCatalog called hadoop:\nSET iceberg.catalog.hadoop.type=hadoop; SET iceberg.catalog.hadoop.warehouse=hdfs://example.com:8020/warehouse; Register an AWS GlueCatalog called glue:\nSET iceberg.catalog.glue.catalog-impl=org.apache.iceberg.aws.GlueCatalog; SET iceberg.catalog.glue.warehouse=s3://my-bucket/my/key/prefix; SET iceberg.catalog.glue.lock-impl=org.apache.iceberg.aws.glue.DynamoLockManager; SET iceberg.catalog.glue.lock.table=myGlueLockTable; DDL Commands #  CREATE EXTERNAL TABLE #  The CREATE EXTERNAL TABLE command is used to overlay a Hive table \u0026ldquo;on top of\u0026rdquo; an existing Iceberg table. Iceberg tables are created using either a Catalog, or an implementation of the Tables interface, and Hive needs to be configured accordingly to operate on these different types of table.\nHive catalog tables #  As described before, tables created by the HiveCatalog with Hive engine feature enabled are directly visible by the Hive engine, so there is no need to create an overlay.\nCustom catalog tables #  For a table in a registered catalog, specify the catalog name in the statement using table property iceberg.catalog. For example, the SQL below creates an overlay for a table in a hadoop type catalog named hadoop_cat:\nSET iceberg.catalog.hadoop_cat.type=hadoop; SET iceberg.catalog.hadoop_cat.warehouse=hdfs://example.com:8020/hadoop_cat; CREATE EXTERNAL TABLE database_a.table_a STORED BY \u0026#39;org.apache.iceberg.mr.hive.HiveIcebergStorageHandler\u0026#39; TBLPROPERTIES (\u0026#39;iceberg.catalog\u0026#39;=\u0026#39;hadoop_cat\u0026#39;); When iceberg.catalog is missing from both table properties and the global Hadoop configuration, HiveCatalog will be used as default.\nPath-based Hadoop tables #  Iceberg tables created using HadoopTables are stored entirely in a directory in a filesystem like HDFS. These tables are considered to have no catalog. To indicate that, set iceberg.catalog property to location_based_table. For example:\nCREATE EXTERNAL TABLE table_a STORED BY \u0026#39;org.apache.iceberg.mr.hive.HiveIcebergStorageHandler\u0026#39; LOCATION \u0026#39;hdfs://some_bucket/some_path/table_a\u0026#39; TBLPROPERTIES (\u0026#39;iceberg.catalog\u0026#39;=\u0026#39;location_based_table\u0026#39;); CREATE TABLE #  Hive also supports directly creating a new Iceberg table through CREATE TABLE statement. For example:\nCREATE TABLE database_a.table_a ( id bigint, name string ) PARTITIONED BY ( dept string ) STORED BY \u0026#39;org.apache.iceberg.mr.hive.HiveIcebergStorageHandler\u0026#39;; to Hive, the table appears to be unpartitioned although the underlying Iceberg table is partitioned.  Due to the limitation of Hive PARTITIONED BY syntax, if you use Hive CREATE TABLE, currently you can only partition by columns, which is translated to Iceberg identity partition transform. You cannot partition by other Iceberg partition transforms such as days(timestamp). To create table with all partition transforms, you need to create the table with other engines like Spark or Flink.  Custom catalog table #  You can also create a new table that is managed by a custom catalog. For example, the following code creates a table in a custom Hadoop catalog:\nSET iceberg.catalog.hadoop_cat.type=hadoop; SET iceberg.catalog.hadoop_cat.warehouse=hdfs://example.com:8020/hadoop_cat; CREATE TABLE database_a.table_a ( id bigint, name string ) PARTITIONED BY ( dept string ) STORED BY \u0026#39;org.apache.iceberg.mr.hive.HiveIcebergStorageHandler\u0026#39; TBLPROPERTIES (\u0026#39;iceberg.catalog\u0026#39;=\u0026#39;hadoop_cat\u0026#39;); If the table to create already exists in the custom catalog, this will create a managed overlay table. This means technically you can omit the EXTERNAL keyword when creating an overlay table. However, this is not recommended because creating managed overlay tables could pose a risk to the shared data files in case of accidental drop table commands from the Hive side, which would unintentionally remove all the data in the table.  DROP TABLE #  Tables can be dropped using the DROP TABLE command:\nDROP TABLE [IF EXISTS] table_name [PURGE]; You can configure purge behavior through global Hadoop configuration or Hive metastore table properties:\n   Config key Default Description     external.table.purge true if all data and metadata should be purged in a table by default    Each Iceberg table\u0026rsquo;s default purge behavior can also be configured through Iceberg table properties:\n   Property Default Description     gc.enabled true if all data and metadata should be purged in the table by default    When changing gc.enabled on the Iceberg table via UpdateProperties, external.table.purge is also updated on HMS table accordingly. When setting external.table.purge as a table prop during Hive CREATE TABLE, gc.enabled is pushed down accordingly to the Iceberg table properties. This makes sure that the 2 properties are always consistent at table level between Hive and Iceberg.\nChanging external.table.purge via Hive ALTER TABLE SET TBLPROPERTIES does not update gc.enabled on the Iceberg table. This is a limitation on Hive 3.1.2 because the HiveMetaHook doesn\u0026rsquo;t have all the hooks for alter tables yet.  Querying with SQL #  Here are the features highlights for Iceberg Hive read support:\n Predicate pushdown: Pushdown of the Hive SQL WHERE clause has been implemented so that these filters are used at the Iceberg TableScan level as well as by the Parquet and ORC Readers. Column projection: Columns from the Hive SQL SELECT clause are projected down to the Iceberg readers to reduce the number of columns read. Hive query engines: Both the MapReduce and Tez query execution engines are supported.  Configurations #  Here are the Hadoop configurations that one can adjust for the Hive reader:\n   Config key Default Description     iceberg.mr.reuse.containers false if Avro reader should reuse containers   iceberg.mr.case.sensitive true if the query is case-sensitive    SELECT #  You should now be able to issue Hive SQL SELECT queries and see the results returned from the underlying Iceberg table, for example:\nSELECT * from table_a; Writing with SQL #  Configurations #  Here are the Hadoop configurations that one can adjust for the Hive writer:\n   Config key Default Description     iceberg.mr.commit.table.thread.pool.size 10 the number of threads of a shared thread pool to execute parallel commits for output tables   iceberg.mr.commit.file.thread.pool.size 10 the number of threads of a shared thread pool to execute parallel commits for files in each output table    INSERT INTO #  Hive supports the standard single-table INSERT INTO operation:\nINSERT INTO table_a VALUES (\u0026#39;a\u0026#39;, 1); INSERT INTO table_a SELECT ...; Multi-table insert is also supported, but it will not be atomic and are committed one table at a time. Partial changes will be visible during the commit process and failures can leave partial changes committed. Changes within a single table will remain atomic.\nHere is an example of inserting into multiple tables at once in Hive SQL:\nFROM customers INSERT INTO target1 SELECT customer_id, first_name INSERT INTO target2 SELECT last_name, customer_id; Type compatibility #  Hive and Iceberg support different set of types. Iceberg can perform type conversion automatically, but not for all combinations, so you may want to understand the type conversion in Iceberg in prior to design the types of columns in your tables. You can enable auto-conversion through Hadoop configuration (not enabled by default):\n   Config key Default Description     iceberg.mr.schema.auto.conversion false if Hive should perform type auto-conversion    Hive type to Iceberg type #  This type conversion table describes how Hive types are converted to the Iceberg types. The conversion applies on both creating Iceberg table and writing to Iceberg table via Hive.\n   Hive Iceberg Notes     boolean boolean    short integer auto-conversion   byte integer auto-conversion   integer integer    long long    float float    double double    date date    timestamp timestamp without timezone    timestamplocaltz timestamp with timezone Hive 3 only   interval_year_month  not supported   interval_day_time  not supported   char string auto-conversion   varchar string auto-conversion   string string    binary binary    decimal decimal    struct struct    list list    map map    union  not supported    "},{"id":9,"href":"/docs/0.13.0/docs/asf/donate/","title":"Donate","section":"ASF","content":"  "},{"id":10,"href":"/docs/0.13.0/python-quickstart/","title":"Python Quickstart","section":"API","content":"Python API Quickstart #  Installation #  Iceberg python is currently in development, for development and testing purposes the best way to install the library is to perform the following steps:\ngit clone https://github.com/apache/iceberg.git cd iceberg/python pip install -e . Testing #  Testing is done using tox. The config can be found in tox.ini within the python directory of the iceberg project.\n# simply run tox from within the python dir tox Examples #  Inspect Table Metadata #  from iceberg.hive import HiveTables # instantiate Hive Tables conf = {\u0026#34;hive.metastore.uris\u0026#34;: \u0026#39;thrift://{hms_host}:{hms_port}\u0026#39;} tables = HiveTables(conf) # load table tbl = tables.load(\u0026#34;iceberg_db.iceberg_test_table\u0026#34;) # inspect metadata print(tbl.schema()) print(tbl.spec()) print(tbl.location()) # get table level record count from pprint import pprint pprint(int(tbl.current_snapshot().summary.get(\u0026#34;total-records\u0026#34;))) "},{"id":11,"href":"/docs/0.13.0/docs/trino/","title":"Trino","section":"Docs","content":"  "},{"id":12,"href":"/docs/0.13.0/docs/prestodb/","title":"Presto","section":"Docs","content":"  "},{"id":13,"href":"/docs/0.13.0/docs/dremio/","title":"Dremio","section":"Docs","content":"  "},{"id":14,"href":"/docs/0.13.0/docs/athena/","title":"Amazon Athena","section":"Docs","content":"  "},{"id":15,"href":"/docs/0.13.0/docs/emr/","title":"Amazon EMR","section":"Docs","content":"  "},{"id":16,"href":"/docs/0.13.0/docs/asf/events/","title":"Events","section":"ASF","content":"  "},{"id":17,"href":"/docs/0.13.0/python-api-intro/","title":"Python API","section":"API","content":"Iceberg Python API #  Much of the python api conforms to the java api. You can get more info about the java api here.\nCatalog #  The Catalog interface, like java provides search and management operations for tables.\nTo create a catalog:\nfrom iceberg.hive import HiveTables # instantiate Hive Tables conf = {\u0026#34;hive.metastore.uris\u0026#34;: \u0026#39;thrift://{hms_host}:{hms_port}\u0026#39;} tables = HiveTables(conf) and to create a table from a catalog:\nfrom iceberg.api.schema import Schema\\ from iceberg.api.types import TimestampType, DoubleType, StringType, NestedField from iceberg.api.partition_spec import PartitionSpecBuilder schema = Schema(NestedField.optional(1, \u0026#34;DateTime\u0026#34;, TimestampType.with_timezone()), NestedField.optional(2, \u0026#34;Bid\u0026#34;, DoubleType.get()), NestedField.optional(3, \u0026#34;Ask\u0026#34;, DoubleType.get()), NestedField.optional(4, \u0026#34;symbol\u0026#34;, StringType.get())) partition_spec = PartitionSpecBuilder(schema).add(1, 1000, \u0026#34;DateTime_day\u0026#34;, \u0026#34;day\u0026#34;).build() tables.create(schema, \u0026#34;test.test_123\u0026#34;, partition) Tables #  The Table interface provides access to table metadata\n schema returns the current table Schema spec returns the current table PartitonSpec properties returns a map of key-value TableProperties currentSnapshot returns the current table Snapshot snapshots returns all valid snapshots for the table snapshot(id) returns a specific snapshot by ID location returns the table’s base location  Tables also provide refresh to update the table to the latest version.\nScanning #  Iceberg table scans start by creating a TableScan object with newScan.\nscan = table.new_scan(); To configure a scan, call filter and select on the TableScan to get a new TableScan with those changes.\nfiltered_scan = scan.filter(Expressions.equal(\u0026#34;id\u0026#34;, 5)) String expressions can also be passed to the filter method.\nfiltered_scan = scan.filter(\u0026#34;id=5\u0026#34;) Schema projections can be applied against a TableScan by passing a list of column names.\nfiltered_scan = scan.select([\u0026#34;col_1\u0026#34;, \u0026#34;col_2\u0026#34;, \u0026#34;col_3\u0026#34;]) Because some data types cannot be read using the python library, a convenience method for excluding columns from projection is provided.\nfiltered_scan = scan.select_except([\u0026#34;unsupported_col_1\u0026#34;, \u0026#34;unsupported_col_2\u0026#34;]) Calls to configuration methods create a new TableScan so that each TableScan is immutable.\nWhen a scan is configured, planFiles, planTasks, and Schema are used to return files, tasks, and the read projection.\nscan = table.new_scan() \\ .filter(\u0026#34;id=5\u0026#34;) \\ .select([\u0026#34;id\u0026#34;, \u0026#34;data\u0026#34;]) projection = scan.schema for task in scan.plan_tasks(): print(task) Types #  Iceberg data types are located in iceberg.api.types.types\nPrimitives #  Primitive type instances are available from static methods in each type class. Types without parameters use get, and types like DecimalType use factory methods:\nIntegerType.get() # int DoubleType.get() # double DecimalType.of(9, 2) # decimal(9, 2) Nested types #  Structs, maps, and lists are created using factory methods in type classes.\nLike struct fields, map keys or values and list elements are tracked as nested fields. Nested fields track field IDs and nullability.\nStruct fields are created using NestedField.optional or NestedField.required. Map value and list element nullability is set in the map and list factory methods.\n# struct\u0026lt;1 id: int, 2 data: optional string\u0026gt; struct = StructType.of([NestedField.required(1, \u0026#34;id\u0026#34;, IntegerType.get()), NestedField.optional(2, \u0026#34;data\u0026#34;, StringType.get()]) ) # map\u0026lt;1 key: int, 2 value: optional string\u0026gt; map_var = MapType.of_optional(1, IntegerType.get(), 2, StringType.get()) # array\u0026lt;1 element: int\u0026gt; list_var = ListType.of_required(1, IntegerType.get()); Expressions #  Iceberg’s Expressions are used to configure table scans. To create Expressions, use the factory methods in Expressions.\nSupported Predicate expressions are:\n is_null not_null equal not_equal less_than less_than_or_equal greater_than greater_than_or_equal  Supported expression Operationsare:\n and or not  Constant expressions are:\n always_true always_false  "},{"id":18,"href":"/docs/0.13.0/python-feature-support/","title":"Python Feature Support","section":"API","content":"Feature Support #  The goal is that the python library will provide a functional, performant subset of the java library. The initial focus has been on reading table metadata as well as providing the capability to both plan and execute a scan.\nFeature Comparison #  Metadata #     Operation Java Python     Get Schema X X   Get Snapshots X X   Plan Scan X X   Plan Scan for Snapshot X X   Update Current Snapshot X    Set Table Properties X    Create Table X X   Drop Table X X   Alter Table X     Read Support #  Pyarrow is used for reading parquet files, so read support is limited to what is currently supported in the pyarrow.parquet package.\nPrimitive Types #     Data Type Java Python     BooleanType X X   DateType X X   DecimalType X X   FloatType X X   IntegerType X X   LongType X X   TimeType X X   TimestampType X X    Nested Types #     Data Type Java Python     ListType of primitives X X   MapType of primitives X X   StructType of primitives X X   ListType of Nested Types X    MapType of Nested Types X     Write Support #  The python client does not currently support write capability\n"},{"id":19,"href":"/docs/0.13.0/flink-connector/","title":"Flink Connector","section":"Flink","content":"Flink Connector #  Apache Flink supports creating Iceberg table directly without creating the explicit Flink catalog in Flink SQL. That means we can just create an iceberg table by specifying 'connector'='iceberg' table option in Flink SQL which is similar to usage in the Flink official document.\nIn Flink, the SQL CREATE TABLE test (..) WITH ('connector'='iceberg', ...) will create a Flink table in current Flink catalog (use GenericInMemoryCatalog by default), which is just mapping to the underlying iceberg table instead of maintaining iceberg table directly in current Flink catalog.\nTo create the table in Flink SQL by using SQL syntax CREATE TABLE test (..) WITH ('connector'='iceberg', ...), Flink iceberg connector provides the following table properties:\n connector: Use the constant iceberg. catalog-name: User-specified catalog name. It\u0026rsquo;s required because the connector don\u0026rsquo;t have any default value. catalog-type: Default to use hive if don\u0026rsquo;t specify any value. The optional values are:  hive: The Hive metastore catalog. hadoop: The hadoop catalog. custom: The customized catalog, see custom catalog for more details.   catalog-database: The iceberg database name in the backend catalog, use the current flink database name by default. catalog-table: The iceberg table name in the backend catalog. Default to use the table name in the flink CREATE TABLE sentence.  Table managed in Hive catalog. #  Before executing the following SQL, please make sure you\u0026rsquo;ve configured the Flink SQL client correctly according to the quick start document.\nThe following SQL will create a Flink table in the current Flink catalog, which maps to the iceberg table default_database.iceberg_table managed in iceberg catalog.\nCREATE TABLE flink_table ( id BIGINT, data STRING ) WITH ( \u0026#39;connector\u0026#39;=\u0026#39;iceberg\u0026#39;, \u0026#39;catalog-name\u0026#39;=\u0026#39;hive_prod\u0026#39;, \u0026#39;uri\u0026#39;=\u0026#39;thrift://localhost:9083\u0026#39;, \u0026#39;warehouse\u0026#39;=\u0026#39;hdfs://nn:8020/path/to/warehouse\u0026#39; ); If you want to create a Flink table mapping to a different iceberg table managed in Hive catalog (such as hive_db.hive_iceberg_table in Hive), then you can create Flink table as following:\nCREATE TABLE flink_table ( id BIGINT, data STRING ) WITH ( \u0026#39;connector\u0026#39;=\u0026#39;iceberg\u0026#39;, \u0026#39;catalog-name\u0026#39;=\u0026#39;hive_prod\u0026#39;, \u0026#39;catalog-database\u0026#39;=\u0026#39;hive_db\u0026#39;, \u0026#39;catalog-table\u0026#39;=\u0026#39;hive_iceberg_table\u0026#39;, \u0026#39;uri\u0026#39;=\u0026#39;thrift://localhost:9083\u0026#39;, \u0026#39;warehouse\u0026#39;=\u0026#39;hdfs://nn:8020/path/to/warehouse\u0026#39; ); The underlying catalog database (hive_db in the above example) will be created automatically if it does not exist when writing records into the Flink table.  Table managed in hadoop catalog #  The following SQL will create a Flink table in current Flink catalog, which maps to the iceberg table default_database.flink_table managed in hadoop catalog.\nCREATE TABLE flink_table ( id BIGINT, data STRING ) WITH ( \u0026#39;connector\u0026#39;=\u0026#39;iceberg\u0026#39;, \u0026#39;catalog-name\u0026#39;=\u0026#39;hadoop_prod\u0026#39;, \u0026#39;catalog-type\u0026#39;=\u0026#39;hadoop\u0026#39;, \u0026#39;warehouse\u0026#39;=\u0026#39;hdfs://nn:8020/path/to/warehouse\u0026#39; ); Table managed in custom catalog #  The following SQL will create a Flink table in current Flink catalog, which maps to the iceberg table default_database.flink_table managed in custom catalog.\nCREATE TABLE flink_table ( id BIGINT, data STRING ) WITH ( \u0026#39;connector\u0026#39;=\u0026#39;iceberg\u0026#39;, \u0026#39;catalog-name\u0026#39;=\u0026#39;custom_prod\u0026#39;, \u0026#39;catalog-type\u0026#39;=\u0026#39;custom\u0026#39;, \u0026#39;catalog-impl\u0026#39;=\u0026#39;com.my.custom.CatalogImpl\u0026#39;, -- More table properties for the customized catalog  \u0026#39;my-additional-catalog-config\u0026#39;=\u0026#39;my-value\u0026#39;, ... ); Please check sections under the Integrations tab for all custom catalogs.\nA complete example. #  Take the Hive catalog as an example:\nCREATE TABLE flink_table ( id BIGINT, data STRING ) WITH ( \u0026#39;connector\u0026#39;=\u0026#39;iceberg\u0026#39;, \u0026#39;catalog-name\u0026#39;=\u0026#39;hive_prod\u0026#39;, \u0026#39;uri\u0026#39;=\u0026#39;thrift://localhost:9083\u0026#39;, \u0026#39;warehouse\u0026#39;=\u0026#39;file:///path/to/warehouse\u0026#39; ); INSERT INTO flink_table VALUES (1, \u0026#39;AAA\u0026#39;), (2, \u0026#39;BBB\u0026#39;), (3, \u0026#39;CCC\u0026#39;); SET execution.result-mode=tableau; SELECT * FROM flink_table; +----+------+ | id | data | +----+------+ | 1 | AAA | | 2 | BBB | | 3 | CCC | +----+------+ 3 rows in set For more details, please refer to the Iceberg Flink document.\n"},{"id":20,"href":"/docs/0.13.0/configuration/","title":"Configuration","section":"Tables","content":"Configuration #  Table properties #  Iceberg tables support table properties to configure table behavior, like the default split size for readers.\nRead properties #     Property Default Description     read.split.target-size 134217728 (128 MB) Target size when combining data input splits   read.split.metadata-target-size 33554432 (32 MB) Target size when combining metadata input splits   read.split.planning-lookback 10 Number of bins to consider when combining input splits   read.split.open-file-cost 4194304 (4 MB) The estimated cost to open a file, used as a minimum weight when combining splits.    Write properties #     Property Default Description     write.format.default parquet Default file format for the table; parquet, avro, or orc   write.parquet.row-group-size-bytes 134217728 (128 MB) Parquet row group size   write.parquet.page-size-bytes 1048576 (1 MB) Parquet page size   write.parquet.dict-size-bytes 2097152 (2 MB) Parquet dictionary page size   write.parquet.compression-codec gzip Parquet compression codec: zstd, brotli, lz4, gzip, snappy, uncompressed   write.parquet.compression-level null Parquet compression level   write.avro.compression-codec gzip Avro compression codec: gzip(deflate with 9 level), gzip, snappy, uncompressed   write.location-provider.impl null Optional custom implemention for LocationProvider   write.metadata.compression-codec none Metadata compression codec; none or gzip   write.metadata.metrics.default truncate(16) Default metrics mode for all columns in the table; none, counts, truncate(length), or full   write.metadata.metrics.column.col1 (not set) Metrics mode for column \u0026lsquo;col1\u0026rsquo; to allow per-column tuning; none, counts, truncate(length), or full   write.target-file-size-bytes 536870912 (512 MB) Controls the size of files generated to target about this many bytes   write.distribution-mode none Defines distribution of write data: none: don\u0026rsquo;t shuffle rows; hash: hash distribute by partition key ; range: range distribute by partition key or sort key if table has an SortOrder   write.wap.enabled false Enables write-audit-publish writes   write.summary.partition-limit 0 Includes partition-level summary stats in snapshot summaries if the changed partition count is less than this limit   write.metadata.delete-after-commit.enabled false Controls whether to delete the oldest version metadata files after commit   write.metadata.previous-versions-max 100 The max number of previous version metadata files to keep before deleting after commit   write.spark.fanout.enabled false Enables Partitioned-Fanout-Writer writes in Spark    Table behavior properties #     Property Default Description     commit.retry.num-retries 4 Number of times to retry a commit before failing   commit.retry.min-wait-ms 100 Minimum time in milliseconds to wait before retrying a commit   commit.retry.max-wait-ms 60000 (1 min) Maximum time in milliseconds to wait before retrying a commit   commit.retry.total-timeout-ms 1800000 (30 min) Total retry timeout period in milliseconds for a commit   commit.status-check.num-retries 3 Number of times to check whether a commit succeeded after a connection is lost before failing due to an unknown commit state   commit.status-check.min-wait-ms 1000 (1s) Minimum time in milliseconds to wait before retrying a status-check   commit.status-check.max-wait-ms 60000 (1 min) Maximum time in milliseconds to wait before retrying a status-check   commit.status-check.total-timeout-ms 1800000 (30 min) Total timeout period in which the commit status-check must succeed, in milliseconds   commit.manifest.target-size-bytes 8388608 (8 MB) Target size when merging manifest files   commit.manifest.min-count-to-merge 100 Minimum number of manifests to accumulate before merging   commit.manifest-merge.enabled true Controls whether to automatically merge manifests on writes   history.expire.max-snapshot-age-ms 432000000 (5 days) Default max age of snapshots to keep while expiring snapshots   history.expire.min-snapshots-to-keep 1 Default min number of snapshots to keep while expiring snapshots   history.expire.max-ref-age-ms Long.MAX_VALUE (forever) For snapshot references except the main branch, default max age of snapshot references to keep while expiring snapshots. The main branch never expires.    Reserved table properties #  Reserved table properties are only used to control behaviors when creating or updating a table. The value of these properties are not persisted as a part of the table metadata.\n   Property Default Description     format-version 1 Table\u0026rsquo;s format version (can be 1 or 2) as defined in the Spec.    Compatibility flags #     Property Default Description     compatibility.snapshot-id-inheritance.enabled false Enables committing snapshots without explicit snapshot IDs    Catalog properties #  Iceberg catalogs support using catalog properties to configure catalog behaviors. Here is a list of commonly used catalog properties:\n   Property Default Description     catalog-impl null a custom Catalog implementation to use by an engine   io-impl null a custom FileIO implementation to use in a catalog   warehouse null the root path of the data warehouse   uri null a URI string, such as Hive metastore URI   clients 2 client pool size    HadoopCatalog and HiveCatalog can access the properties in their constructors. Any other custom catalog can access the properties by implementing Catalog.initialize(catalogName, catalogProperties). The properties can be manually constructed or passed in from a compute engine like Spark or Flink. Spark uses its session properties as catalog properties, see more details in the Spark configuration section. Flink passes in catalog properties through CREATE CATALOG statement, see more details in the Flink section.\nLock catalog properties #  Here are the catalog properties related to locking. They are used by some catalog implementations to control the locking behavior during commits.\n   Property Default Description     lock-impl null a custom implementation of the lock manager, the actual interface depends on the catalog used   lock.table null an auxiliary table for locking, such as in AWS DynamoDB lock manager   lock.acquire-interval-ms 5 seconds the interval to wait between each attempt to acquire a lock   lock.acquire-timeout-ms 3 minutes the maximum time to try acquiring a lock   lock.heartbeat-interval-ms 3 seconds the interval to wait between each heartbeat after acquiring a lock   lock.heartbeat-timeout-ms 15 seconds the maximum time without a heartbeat to consider a lock expired    Hadoop configuration #  The following properties from the Hadoop configuration are used by the Hive Metastore connector.\n   Property Default Description     iceberg.hive.client-pool-size 5 The size of the Hive client pool when tracking tables in HMS   iceberg.hive.lock-timeout-ms 180000 (3 min) Maximum time in milliseconds to acquire a lock   iceberg.hive.lock-check-min-wait-ms 50 Minimum time in milliseconds to check back on the status of lock acquisition   iceberg.hive.lock-check-max-wait-ms 5000 Maximum time in milliseconds to check back on the status of lock acquisition    Note: iceberg.hive.lock-check-max-wait-ms should be less than the transaction timeout of the Hive Metastore (hive.txn.timeout or metastore.txn.timeout in the newer versions). Otherwise, the heartbeats on the lock (which happens during the lock checks) would end up expiring in the Hive Metastore before the lock is retried from Iceberg.\n"},{"id":21,"href":"/docs/0.13.0/evolution/","title":"Evolution","section":"Tables","content":"Evolution #  Iceberg supports in-place table evolution. You can evolve a table schema just like SQL \u0026ndash; even in nested structures \u0026ndash; or change partition layout when data volume changes. Iceberg does not require costly distractions, like rewriting table data or migrating to a new table.\nFor example, Hive table partitioning cannot change so moving from a daily partition layout to an hourly partition layout requires a new table. And because queries are dependent on partitions, queries must be rewritten for the new table. In some cases, even changes as simple as renaming a column are either not supported, or can cause data correctness problems.\nSchema evolution #  Iceberg supports the following schema evolution changes:\n Add \u0026ndash; add a new column to the table or to a nested struct Drop \u0026ndash; remove an existing column from the table or a nested struct Rename \u0026ndash; rename an existing column or field in a nested struct Update \u0026ndash; widen the type of a column, struct field, map key, map value, or list element Reorder \u0026ndash; change the order of columns or fields in a nested struct  Iceberg schema updates are metadata changes, so no data files need to be rewritten to perform the update.\nNote that map keys do not support adding or dropping struct fields that would change equality.\nCorrectness #  Iceberg guarantees that schema evolution changes are independent and free of side-effects, without rewriting files:\n Added columns never read existing values from another column. Dropping a column or field does not change the values in any other column. Updating a column or field does not change values in any other column. Changing the order of columns or fields in a struct does not change the values associated with a column or field name.  Iceberg uses unique IDs to track each column in a table. When you add a column, it is assigned a new ID so existing data is never used by mistake.\n Formats that track columns by name can inadvertently un-delete a column if a name is reused, which violates #1. Formats that track columns by position cannot delete columns without changing the names that are used for each column, which violates #2.  Partition evolution #  Iceberg table partitioning can be updated in an existing table because queries do not reference partition values directly.\nWhen you evolve a partition spec, the old data written with an earlier spec remains unchanged. New data is written using the new spec in a new layout. Metadata for each of the partition versions is kept separately. Because of this, when you start writing queries, you get split planning. This is where each partition layout plans files separately using the filter it derives for that specific partition layout. Here\u0026rsquo;s a visual representation of a contrived example:\nThe data for 2008 is partitioned by month. Starting from 2009 the table is updated so that the data is instead partitioned by day. Both partitioning layouts are able to coexist in the same table.\nIceberg uses hidden partitioning, so you don\u0026rsquo;t need to write queries for a specific partition layout to be fast. Instead, you can write queries that select the data you need, and Iceberg automatically prunes out files that don\u0026rsquo;t contain matching data.\nPartition evolution is a metadata operation and does not eagerly rewrite files.\nIceberg\u0026rsquo;s Java table API provides updateSpec API to update partition spec. For example, the following code could be used to update the partition spec to add a new partition field that places id column values into 8 buckets and remove an existing partition field category:\nTable sampleTable = ...; sampleTable.updateSpec() .addField(bucket(\u0026#34;id\u0026#34;, 8)) .removeField(\u0026#34;category\u0026#34;) .commit(); Spark supports updating partition spec through its ALTER TABLE SQL statement, see more details in Spark SQL.\nSort order evolution #  Similar to partition spec, Iceberg sort order can also be updated in an existing table. When you evolve a sort order, the old data written with an earlier order remains unchanged. Engines can always choose to write data in the latest sort order or unsorted when sorting is prohibitively expensive.\nIceberg\u0026rsquo;s Java table API provides replaceSortOrder API to update partition spec. For example, the following code could be used to create a new sort order with id column sorted in ascending order with nulls last, and category column sorted in descending order with nulls first:\nTable sampleTable = ...; sampleTable.replaceSortOrder() .asc(\u0026#34;id\u0026#34;, NullOrder.NULLS_LAST) .dec(\u0026#34;category\u0026#34;, NullOrder.NULL_FIRST) .commit(); Spark supports updating sort order through its ALTER TABLE SQL statement, see more details in Spark SQL.\n"},{"id":22,"href":"/docs/0.13.0/maintenance/","title":"Maintenance","section":"Tables","content":"Maintenance #  Maintenance operations require the Table instance. Please refer Java API quickstart page to refer how to load an existing table.  Recommended Maintenance #  Expire Snapshots #  Each write to an Iceberg table creates a new snapshot, or version, of a table. Snapshots can be used for time-travel queries, or the table can be rolled back to any valid snapshot.\nSnapshots accumulate until they are expired by the expireSnapshots operation. Regularly expiring snapshots is recommended to delete data files that are no longer needed, and to keep the size of table metadata small.\nThis example expires snapshots that are older than 1 day:\nTable table = ... long tsToExpire = System.currentTimeMillis() - (1000 * 60 * 60 * 24); // 1 day table.expireSnapshots() .expireOlderThan(tsToExpire) .commit(); See the ExpireSnapshots Javadoc to see more configuration options.\nThere is also a Spark action that can run table expiration in parallel for large tables:\nTable table = ... SparkActions .get() .expireSnapshots(table) .expireOlderThan(tsToExpire) .execute(); Expiring old snapshots removes them from metadata, so they are no longer available for time travel queries.\nData files are not deleted until they are no longer referenced by a snapshot that may be used for time travel or rollback. Regularly expiring snapshots deletes unused data files.  Remove old metadata files #  Iceberg keeps track of table metadata using JSON files. Each change to a table produces a new metadata file to provide atomicity.\nOld metadata files are kept for history by default. Tables with frequent commits, like those written by streaming jobs, may need to regularly clean metadata files.\nTo automatically clean metadata files, set write.metadata.delete-after-commit.enabled=true in table properties. This will keep some metadata files (up to write.metadata.previous-versions-max) and will delete the oldest metadata file after each new one is created.\n   Property Description     write.metadata.delete-after-commit.enabled Whether to delete old metadata files after each table commit   write.metadata.previous-versions-max The number of old metadata files to keep    See table write properties for more details.\nDelete orphan files #  In Spark and other distributed processing engines, task or job failures can leave files that are not referenced by table metadata, and in some cases normal snapshot expiration may not be able to determine a file is no longer needed and delete it.\nTo clean up these \u0026ldquo;orphan\u0026rdquo; files under a table location, use the deleteOrphanFiles action.\nTable table = ... SparkActions .get() .deleteOrphanFiles(table) .execute(); See the DeleteOrphanFiles Javadoc to see more configuration options.\nThis action may take a long time to finish if you have lots of files in data and metadata directories. It is recommended to execute this periodically, but you may not need to execute this often.\nIt is dangerous to remove orphan files with a retention interval shorter than the time expected for any write to complete because it might corrupt the table if in-progress files are considered orphaned and are deleted. The default interval is 3 days.  Iceberg uses the string representations of paths when determining which files need to be removed. On some file systems, the path can change over time, but it still represents the same file. For example, if you change authorities for an HDFS cluster, none of the old path urls used during creation will match those that appear in a current listing. This will lead to data loss when RemoveOrphanFiles is run. Please be sure the entries in your MetadataTables match those listed by the Hadoop FileSystem API to avoid unintentional deletion.  Optional Maintenance #  Some tables require additional maintenance. For example, streaming queries may produce small data files that should be compacted into larger files. And some tables can benefit from rewriting manifest files to make locating data for queries much faster.\nCompact data files #  Iceberg tracks each data file in a table. More data files leads to more metadata stored in manifest files, and small data files causes an unnecessary amount of metadata and less efficient queries from file open costs.\nIceberg can compact data files in parallel using Spark with the rewriteDataFiles action. This will combine small files into larger files to reduce metadata overhead and runtime file open cost.\nTable table = ... SparkActions .get() .rewriteDataFiles(table) .filter(Expressions.equal(\u0026#34;date\u0026#34;, \u0026#34;2020-08-18\u0026#34;)) .option(\u0026#34;target-file-size-bytes\u0026#34;, Long.toString(500 * 1024 * 1024)) // 500 MB  .execute(); The files metadata table is useful for inspecting data file sizes and determining when to compact partitions.\nSee the RewriteDataFiles Javadoc to see more configuration options.\nRewrite manifests #  Iceberg uses metadata in its manifest list and manifest files speed up query planning and to prune unnecessary data files. The metadata tree functions as an index over a table\u0026rsquo;s data.\nManifests in the metadata tree are automatically compacted in the order they are added, which makes queries faster when the write pattern aligns with read filters. For example, writing hourly-partitioned data as it arrives is aligned with time range query filters.\nWhen a table\u0026rsquo;s write pattern doesn\u0026rsquo;t align with the query pattern, metadata can be rewritten to re-group data files into manifests using rewriteManifests or the rewriteManifests action (for parallel rewrites using Spark).\nThis example rewrites small manifests and groups data files by the first partition field.\nTable table = ... SparkActions .get() .rewriteManifests(table) .rewriteIf(file -\u0026gt; file.length() \u0026lt; 10 * 1024 * 1024) // 10 MB  .execute(); See the RewriteManifests Javadoc to see more configuration options.\n"},{"id":23,"href":"/docs/0.13.0/partitioning/","title":"Partitioning","section":"Tables","content":"Partitioning #  What is partitioning? #  Partitioning is a way to make queries faster by grouping similar rows together when writing.\nFor example, queries for log entries from a logs table would usually include a time range, like this query for logs between 10 and 12 AM:\nSELECT level, message FROM logs WHERE event_time BETWEEN \u0026#39;2018-12-01 10:00:00\u0026#39; AND \u0026#39;2018-12-01 12:00:00\u0026#39; Configuring the logs table to partition by the date of event_time will group log events into files with the same event date. Iceberg keeps track of that date and will use it to skip files for other dates that don\u0026rsquo;t have useful data.\nIceberg can partition timestamps by year, month, day, and hour granularity. It can also use a categorical column, like level in this logs example, to store rows together and speed up queries.\nWhat does Iceberg do differently? #  Other tables formats like Hive support partitioning, but Iceberg supports hidden partitioning.\n Iceberg handles the tedious and error-prone task of producing partition values for rows in a table. Iceberg avoids reading unnecessary partitions automatically. Consumers don\u0026rsquo;t need to know how the table is partitioned and add extra filters to their queries. Iceberg partition layouts can evolve as needed.  Partitioning in Hive #  To demonstrate the difference, consider how Hive would handle a logs table.\nIn Hive, partitions are explicit and appear as a column, so the logs table would have a column called event_date. When writing, an insert needs to supply the data for the event_date column:\nINSERT INTO logs PARTITION (event_date) SELECT level, message, event_time, format_time(event_time, \u0026#39;YYYY-MM-dd\u0026#39;) FROM unstructured_log_source Similarly, queries that search through the logs table must have an event_date filter in addition to an event_time filter.\nSELECT level, count(1) as count FROM logs WHERE event_time BETWEEN \u0026#39;2018-12-01 10:00:00\u0026#39; AND \u0026#39;2018-12-01 12:00:00\u0026#39; AND event_date = \u0026#39;2018-12-01\u0026#39; If the event_date filter were missing, Hive would scan through every file in the table because it doesn\u0026rsquo;t know that the event_time column is related to the event_date column.\nProblems with Hive partitioning #  Hive must be given partition values. In the logs example, it doesn\u0026rsquo;t know the relationship between event_time and event_date.\nThis leads to several problems:\n Hive can\u0026rsquo;t validate partition values \u0026ndash; it is up to the writer to produce the correct value  Using the wrong format, 2018-12-01 instead of 20181201, produces silently incorrect results, not query failures Using the wrong source column, like processing_time, or time zone also causes incorrect results, not failures   It is up to the user to write queries correctly  Using the wrong format also leads to silently incorrect results Users that don\u0026rsquo;t understand a table\u0026rsquo;s physical layout get needlessly slow queries \u0026ndash; Hive can\u0026rsquo;t translate filters automatically   Working queries are tied to the table\u0026rsquo;s partitioning scheme, so partitioning configuration cannot be changed without breaking queries  Iceberg\u0026rsquo;s hidden partitioning #  Iceberg produces partition values by taking a column value and optionally transforming it. Iceberg is responsible for converting event_time into event_date, and keeps track of the relationship.\nTable partitioning is configured using these relationships. The logs table would be partitioned by date(event_time) and level.\nBecause Iceberg doesn\u0026rsquo;t require user-maintained partition columns, it can hide partitioning. Partition values are produced correctly every time and always used to speed up queries, when possible. Producers and consumers wouldn\u0026rsquo;t even see event_date.\nMost importantly, queries no longer depend on a table\u0026rsquo;s physical layout. With a separation between physical and logical, Iceberg tables can evolve partition schemes over time as data volume changes. Misconfigured tables can be fixed without an expensive migration.\nFor details about all the supported hidden partition transformations, see the Partition Transforms section.\nFor details about updating a table\u0026rsquo;s partition spec, see the partition evolution section.\n"},{"id":24,"href":"/docs/0.13.0/performance/","title":"Performance","section":"Tables","content":"Performance #   Iceberg is designed for huge tables and is used in production where a single table can contain tens of petabytes of data. Even multi-petabyte tables can be read from a single node, without needing a distributed SQL engine to sift through table metadata.  Scan planning #  Scan planning is the process of finding the files in a table that are needed for a query.\nPlanning in an Iceberg table fits on a single node because Iceberg\u0026rsquo;s metadata can be used to prune metadata files that aren\u0026rsquo;t needed, in addition to filtering data files that don\u0026rsquo;t contain matching data.\nFast scan planning from a single node enables:\n Lower latency SQL queries \u0026ndash; by eliminating a distributed scan to plan a distributed scan Access from any client \u0026ndash; stand-alone processes can read data directly from Iceberg tables  Metadata filtering #  Iceberg uses two levels of metadata to track the files in a snapshot.\n Manifest files store a list of data files, along each data file\u0026rsquo;s partition data and column-level stats A manifest list stores the snapshot\u0026rsquo;s list of manifests, along with the range of values for each partition field  For fast scan planning, Iceberg first filters manifests using the partition value ranges in the manifest list. Then, it reads each manifest to get data files. With this scheme, the manifest list acts as an index over the manifest files, making it possible to plan without reading all manifests.\nIn addition to partition value ranges, a manifest list also stores the number of files added or deleted in a manifest to speed up operations like snapshot expiration.\nData filtering #  Manifest files include a tuple of partition data and column-level stats for each data file.\nDuring planning, query predicates are automatically converted to predicates on the partition data and applied first to filter data files. Next, column-level value counts, null counts, lower bounds, and upper bounds are used to eliminate files that cannot match the query predicate.\nBy using upper and lower bounds to filter data files at planning time, Iceberg uses clustered data to eliminate splits without running tasks. In some cases, this is a 10x performance improvement.\n"},{"id":25,"href":"/docs/0.13.0/reliability/","title":"Reliability","section":"Tables","content":"Reliability #  Iceberg was designed to solve correctness problems that affect Hive tables running in S3.\nHive tables track data files using both a central metastore for partitions and a file system for individual files. This makes atomic changes to a table\u0026rsquo;s contents impossible, and eventually consistent stores like S3 may return incorrect results due to the use of listing files to reconstruct the state of a table. It also requires job planning to make many slow listing calls: O(n) with the number of partitions.\nIceberg tracks the complete list of data files in each snapshot using a persistent tree structure. Every write or delete produces a new snapshot that reuses as much of the previous snapshot\u0026rsquo;s metadata tree as possible to avoid high write volumes.\nValid snapshots in an Iceberg table are stored in the table metadata file, along with a reference to the current snapshot. Commits replace the path of the current table metadata file using an atomic operation. This ensures that all updates to table data and metadata are atomic, and is the basis for serializable isolation.\nThis results in improved reliability guarantees:\n Serializable isolation: All table changes occur in a linear history of atomic table updates Reliable reads: Readers always use a consistent snapshot of the table without holding a lock Version history and rollback: Table snapshots are kept as history and tables can roll back if a job produces bad data Safe file-level operations. By supporting atomic changes, Iceberg enables new use cases, like safely compacting small files and safely appending late data to tables  This design also has performance benefits:\n O(1) RPCs to plan: Instead of listing O(n) directories in a table to plan a job, reading a snapshot requires O(1) RPC calls Distributed planning: File pruning and predicate push-down is distributed to jobs, removing the metastore as a bottleneck Finer granularity partitioning: Distributed planning and O(1) RPC calls remove the current barriers to finer-grained partitioning  Concurrent write operations #  Iceberg supports multiple concurrent writes using optimistic concurrency.\nEach writer assumes that no other writers are operating and writes out new table metadata for an operation. Then, the writer attempts to commit by atomically swapping the new table metadata file for the existing metadata file.\nIf the atomic swap fails because another writer has committed, the failed writer retries by writing a new metadata tree based on the the new current table state.\nCost of retries #  Writers avoid expensive retry operations by structuring changes so that work can be reused across retries.\nFor example, appends usually create a new manifest file for the appended data files, which can be added to the table without rewriting the manifest on every attempt.\nRetry validation #  Commits are structured as assumptions and actions. After a conflict, a writer checks that the assumptions are met by the current table state. If the assumptions are met, then it is safe to re-apply the actions and commit.\nFor example, a compaction might rewrite file_a.avro and file_b.avro as merged.parquet. This is safe to commit as long as the table still contains both file_a.avro and file_b.avro. If either file was deleted by a conflicting commit, then the operation must fail. Otherwise, it is safe to remove the source files and add the merged file.\nCompatibility #  By avoiding file listing and rename operations, Iceberg tables are compatible with any object store. No consistent listing is required.\n"},{"id":26,"href":"/docs/0.13.0/schemas/","title":"Schemas","section":"Tables","content":"Schemas #  Iceberg tables support the following types:\n   Type Description Notes     boolean True or false    int 32-bit signed integers Can promote to long   long 64-bit signed integers    float 32-bit IEEE 754 floating point Can promote to double   double 64-bit IEEE 754 floating point    decimal(P,S) Fixed-point decimal; precision P, scale S Scale is fixed and precision must be 38 or less   date Calendar date without timezone or time    time Time of day without date, timezone Stored as microseconds   timestamp Timestamp without timezone Stored as microseconds   timestamptz Timestamp with timezone Stored as microseconds   string Arbitrary-length character sequences Encoded with UTF-8   fixed(L) Fixed-length byte array of length L    binary Arbitrary-length byte array    struct\u0026lt;...\u0026gt; A record with named fields of any data type    list\u0026lt;E\u0026gt; A list with elements of any data type    map\u0026lt;K, V\u0026gt; A map with keys and values of any data type     Iceberg tracks each field in a table schema using an ID that is never reused in a table. See correctness guarantees for more information.\n"},{"id":27,"href":"/docs/0.13.0/aws/","title":"AWS","section":"Integrations","content":"Iceberg AWS Integrations #  Iceberg provides integration with different AWS services through the iceberg-aws module. This section describes how to use Iceberg with AWS.\nEnabling AWS Integration #  The iceberg-aws module is bundled with Spark and Flink engine runtimes for all versions from 0.11.0 onwards. However, the AWS clients are not bundled so that you can use the same client version as your application. You will need to provide the AWS v2 SDK because that is what Iceberg depends on. You can choose to use the AWS SDK bundle, or individual AWS client packages (Glue, S3, DynamoDB, KMS, STS) if you would like to have a minimal dependency footprint.\nAll the default AWS clients use the URL Connection HTTP Client for HTTP connection management. This dependency is not part of the AWS SDK bundle and needs to be added separately. To choose a different HTTP client library such as Apache HTTP Client, see the section client customization for more details.\nAll the AWS module features can be loaded through custom catalog properties, you can go to the documentations of each engine to see how to load a custom catalog. Here are some examples.\nSpark #  For example, to use AWS features with Spark 3 and AWS clients version 2.15.40, you can start the Spark SQL shell with:\n# add Iceberg dependency ICEBERG_VERSION=0.13.0 DEPENDENCIES=\u0026#34;org.apache.iceberg:iceberg-spark3-runtime:$ICEBERG_VERSION\u0026#34; # add AWS dependnecy AWS_SDK_VERSION=2.15.40 AWS_MAVEN_GROUP=software.amazon.awssdk AWS_PACKAGES=( \u0026#34;bundle\u0026#34; \u0026#34;url-connection-client\u0026#34; ) for pkg in \u0026#34;${AWS_PACKAGES[@]}\u0026#34;; do DEPENDENCIES+=\u0026#34;,$AWS_MAVEN_GROUP:$pkg:$AWS_SDK_VERSION\u0026#34; done # start Spark SQL client shell spark-sql --packages $DEPENDENCIES \\  --conf spark.sql.catalog.my_catalog=org.apache.iceberg.spark.SparkCatalog \\  --conf spark.sql.catalog.my_catalog.warehouse=s3://my-bucket/my/key/prefix \\  --conf spark.sql.catalog.my_catalog.catalog-impl=org.apache.iceberg.aws.glue.GlueCatalog \\  --conf spark.sql.catalog.my_catalog.io-impl=org.apache.iceberg.aws.s3.S3FileIO \\  --conf spark.sql.catalog.my_catalog.lock-impl=org.apache.iceberg.aws.glue.DynamoLockManager \\  --conf spark.sql.catalog.my_catalog.lock.table=myGlueLockTable As you can see, In the shell command, we use --packages to specify the additional AWS bundle and HTTP client dependencies with their version as 2.15.40.\nFlink #  To use AWS module with Flink, you can download the necessary dependencies and specify them when starting the Flink SQL client:\n# download Iceberg dependency ICEBERG_VERSION=0.13.0 MAVEN_URL=https://repo1.maven.org/maven2 ICEBERG_MAVEN_URL=$MAVEN_URL/org/apache/iceberg wget $ICEBERG_MAVEN_URL/iceberg-flink-runtime/$ICEBERG_VERSION/iceberg-flink-runtime-$ICEBERG_VERSION.jar # download AWS dependnecy AWS_SDK_VERSION=2.15.40 AWS_MAVEN_URL=$MAVEN_URL/software/amazon/awssdk AWS_PACKAGES=( \u0026#34;bundle\u0026#34; \u0026#34;url-connection-client\u0026#34; ) for pkg in \u0026#34;${AWS_PACKAGES[@]}\u0026#34;; do wget $AWS_MAVEN_URL/$pkg/$AWS_SDK_VERSION/$pkg-$AWS_SDK_VERSION.jar done # start Flink SQL client shell /path/to/bin/sql-client.sh embedded \\  -j iceberg-flink-runtime-$ICEBERG_VERSION.jar \\  -j bundle-$AWS_SDK_VERSION.jar \\  -j url-connection-client-$AWS_SDK_VERSION.jar \\  shell With those dependencies, you can create a Flink catalog like the following:\nCREATE CATALOG my_catalog WITH ( \u0026#39;type\u0026#39;=\u0026#39;iceberg\u0026#39;, \u0026#39;warehouse\u0026#39;=\u0026#39;s3://my-bucket/my/key/prefix\u0026#39;, \u0026#39;catalog-impl\u0026#39;=\u0026#39;org.apache.iceberg.aws.glue.GlueCatalog\u0026#39;, \u0026#39;io-impl\u0026#39;=\u0026#39;org.apache.iceberg.aws.s3.S3FileIO\u0026#39;, \u0026#39;lock-impl\u0026#39;=\u0026#39;org.apache.iceberg.aws.glue.DynamoLockManager\u0026#39;, \u0026#39;lock.table\u0026#39;=\u0026#39;myGlueLockTable\u0026#39; ); You can also specify the catalog configurations in sql-client-defaults.yaml to preload it:\ncatalogs: - name: my_catalog type: iceberg warehouse: s3://my-bucket/my/key/prefix catalog-impl: org.apache.iceberg.aws.glue.GlueCatalog io-impl: org.apache.iceberg.aws.s3.S3FileIO lock-impl: org.apache.iceberg.aws.glue.DynamoLockManager lock.table: myGlueLockTable Hive #  To use AWS module with Hive, you can download the necessary dependencies similar to the Flink example, and then add them to the Hive classpath or add the jars at runtime in CLI:\nadd jar /my/path/to/iceberg-hive-runtime.jar; add jar /my/path/to/aws/bundle.jar; add jar /my/path/to/aws/url-connection-client.jar; With those dependencies, you can register a Glue catalog and create external tables in Hive at runtime in CLI by:\nSET iceberg.engine.hive.enabled=true; SET hive.vectorized.execution.enabled=false; SET iceberg.catalog.glue.catalog-impl=org.apache.iceberg.aws.glue.GlueCatalog; SET iceberg.catalog.glue.warehouse=s3://my-bucket/my/key/prefix; SET iceberg.catalog.glue.lock-impl=org.apache.iceberg.aws.glue.DynamoLockManager; SET iceberg.catalog.glue.lock.table=myGlueLockTable; -- suppose you have an Iceberg table database_a.table_a created by GlueCatalog CREATE EXTERNAL TABLE database_a.table_a STORED BY \u0026#39;org.apache.iceberg.mr.hive.HiveIcebergStorageHandler\u0026#39; TBLPROPERTIES (\u0026#39;iceberg.catalog\u0026#39;=\u0026#39;glue\u0026#39;); You can also preload the catalog by setting the configurations above in hive-site.xml.\nCatalogs #  There are multiple different options that users can choose to build an Iceberg catalog with AWS.\nGlue Catalog #  Iceberg enables the use of AWS Glue as the Catalog implementation. When used, an Iceberg namespace is stored as a Glue Database, an Iceberg table is stored as a Glue Table, and every Iceberg table version is stored as a Glue TableVersion. You can start using Glue catalog by specifying the catalog-impl as org.apache.iceberg.aws.glue.GlueCatalog, just like what is shown in the enabling AWS integration section above. More details about loading the catalog can be found in individual engine pages, such as Spark and Flink.\nGlue Catalog ID #  There is a unique Glue metastore in each AWS account and each AWS region. By default, GlueCatalog chooses the Glue metastore to use based on the user\u0026rsquo;s default AWS client credential and region setup. You can specify the Glue catalog ID through glue.id catalog property to point to a Glue catalog in a different AWS account. The Glue catalog ID is your numeric AWS account ID. If the Glue catalog is in a different region, you should configure you AWS client to point to the correct region, see more details in AWS client customization.\nSkip Archive #  By default, Glue stores all the table versions created and user can rollback a table to any historical version if needed. However, if you are streaming data to Iceberg, this will easily create a lot of Glue table versions. Therefore, it is recommended to turn off the archive feature in Glue by setting glue.skip-archive to true. For more details, please read Glue Quotas and the UpdateTable API.\nDynamoDB for Commit Locking #  Glue does not have a strong guarantee over concurrent updates to a table. Although it throws ConcurrentModificationException when detecting two processes updating a table at the same time, there is no guarantee that one update would not clobber the other update. Therefore, DynamoDB can be used for Glue, so that for every commit, GlueCatalog first obtains a lock using a helper DynamoDB table and then try to safely modify the Glue table.\nThis feature requires the following lock related catalog properties:\n Set lock-impl as org.apache.iceberg.aws.glue.DynamoLockManager. Set lock.table as the DynamoDB table name you would like to use. If the lock table with the given name does not exist in DynamoDB, a new table is created with billing mode set as pay-per-request.  Other lock related catalog properties can also be used to adjust locking behaviors such as heartbeat interval. For more details, please refer to Lock catalog properties.\nWarehouse Location #  Similar to all other catalog implementations, warehouse is a required catalog property to determine the root path of the data warehouse in storage. By default, Glue only allows a warehouse location in S3 because of the use of S3FileIO. To store data in a different local or cloud store, Glue catalog can switch to use HadoopFileIO or any custom FileIO by setting the io-impl catalog property. Details about this feature can be found in the custom FileIO section.\nTable Location #  By default, the root location for a table my_table of namespace my_ns is at my-warehouse-location/my-ns.db/my-table. This default root location can be changed at both namespace and table level.\nTo use a different path prefix for all tables under a namespace, use AWS console or any AWS Glue client SDK you like to update the locationUri attribute of the corresponding Glue database. For example, you can update the locationUri of my_ns to s3://my-ns-bucket, then any newly created table will have a default root location under the new prefix. For instance, a new table my_table_2 will have its root location at s3://my-ns-bucket/my_table_2.\nTo use a completely different root path for a specific table, set the location table property to the desired root path value you want. For example, in Spark SQL you can do:\nCREATE TABLE my_catalog.my_ns.my_table ( id bigint, data string, category string) USING iceberg OPTIONS (\u0026#39;location\u0026#39;=\u0026#39;s3://my-special-table-bucket\u0026#39;) PARTITIONED BY (category); For engines like Spark that supports the LOCATION keyword, the above SQL statement is equivalent to:\nCREATE TABLE my_catalog.my_ns.my_table ( id bigint, data string, category string) USING iceberg LOCATION \u0026#39;s3://my-special-table-bucket\u0026#39; PARTITIONED BY (category); DynamoDB Catalog #  Iceberg supports using a DynamoDB table to record and manage database and table information.\nConfigurations #  The DynamoDB catalog supports the following configurations:\n   Property Default Description     dynamodb.table-name iceberg name of the DynamoDB table used by DynamoDbCatalog    Internal Table Design #  The DynamoDB table is designed with the following columns:\n   Column Key Type Description     identifier partition key string table identifier such as db1.table1, or string NAMESPACE for namespaces   namespace sort key string namespace name. A global secondary index (GSI) is created with namespace as partition key, identifier as sort key, no other projected columns   v  string row version, used for optimistic locking   updated_at  number timestamp (millis) of the last update   created_at  number timestamp (millis) of the table creation   p.\u0026lt;property_key\u0026gt;  string Iceberg-defined table properties including table_type, metadata_location and previous_metadata_location or namespace properties    This design has the following benefits:\n it avoids potential hot partition issue if there are heavy write traffic to the tables within the same namespace, because the partition key is at the table level namespace operations are clustered in a single partition to avoid affecting table commit operations a sort key to partition key reverse GSI is used for list table operation, and all other operations are single row ops or single partition query. No full table scan is needed for any operation in the catalog. a string UUID version field v is used instead of updated_at to avoid 2 processes committing at the same millisecond multi-row transaction is used for catalog.renameTable to ensure idempotency properties are flattened as top level columns so that user can add custom GSI on any property field to customize the catalog. For example, users can store owner information as table property owner, and search tables by owner by adding a GSI on the p.owner column.  RDS JDBC Catalog #  Iceberg also supports JDBC catalog which uses a table in a relational database to manage Iceberg tables. You can configure to use JDBC catalog with relational database services like AWS RDS. Read the JDBC integration page for guides and examples about using the JDBC catalog. Read this AWS documentation for more details about configuring JDBC catalog with IAM authentication.\nWhich catalog to choose? #  With all the available options, we offer the following guidance when choosing the right catalog to use for your application:\n if your organization has an existing Glue metastore or plans to use the AWS analytics ecosystem including Glue, Athena, EMR, Redshift and LakeFormation, Glue catalog provides the easiest integration. if your application requires frequent updates to table or high read and write throughput (e.g. streaming write), DynamoDB catalog provides the best performance through optimistic locking. if you would like to enforce access control for tables in a catalog, Glue tables can be managed as an IAM resource, whereas DynamoDB catalog tables can only be managed through item-level permission which is much more complicated. if you would like to query tables based on table property information without the need to scan the entire catalog, DynamoDB catalog allows you to build secondary indexes for any arbitrary property field and provide efficient query performance. if you would like to have the benefit of DynamoDB catalog while also connect to Glue, you can enable DynamoDB stream with Lambda trigger to asynchronously update your Glue metastore with table information in the DynamoDB catalog. if your organization already maintains an existing relational database in RDS or uses serverless Aurora to manage tables, JDBC catalog provides the easiest integration.  S3 FileIO #  Iceberg allows users to write data to S3 through S3FileIO. GlueCatalog by default uses this FileIO, and other catalogs can load this FileIO using the io-impl catalog property.\nProgressive Multipart Upload #  S3FileIO implements a customized progressive multipart upload algorithm to upload data. Data files are uploaded by parts in parallel as soon as each part is ready, and each file part is deleted as soon as its upload process completes. This provides maximized upload speed and minimized local disk usage during uploads. Here are the configurations that users can tune related to this feature:\n   Property Default Description     s3.multipart.num-threads the available number of processors in the system number of threads to use for uploading parts to S3 (shared across all output streams)   s3.multipart.part-size-bytes 32MB the size of a single part for multipart upload requests   s3.multipart.threshold 1.5 the threshold expressed as a factor times the multipart size at which to switch from uploading using a single put object request to uploading using multipart upload   s3.staging-dir java.io.tmpdir property value the directory to hold temporary files    S3 Server Side Encryption #  S3FileIO supports all 3 S3 server side encryption modes:\n SSE-S3: When you use Server-Side Encryption with Amazon S3-Managed Keys (SSE-S3), each object is encrypted with a unique key. As an additional safeguard, it encrypts the key itself with a master key that it regularly rotates. Amazon S3 server-side encryption uses one of the strongest block ciphers available, 256-bit Advanced Encryption Standard (AES-256), to encrypt your data. SSE-KMS: Server-Side Encryption with Customer Master Keys (CMKs) Stored in AWS Key Management Service (SSE-KMS) is similar to SSE-S3, but with some additional benefits and charges for using this service. There are separate permissions for the use of a CMK that provides added protection against unauthorized access of your objects in Amazon S3. SSE-KMS also provides you with an audit trail that shows when your CMK was used and by whom. Additionally, you can create and manage customer managed CMKs or use AWS managed CMKs that are unique to you, your service, and your Region. SSE-C: With Server-Side Encryption with Customer-Provided Keys (SSE-C), you manage the encryption keys and Amazon S3 manages the encryption, as it writes to disks, and decryption, when you access your objects.  To enable server side encryption, use the following configuration properties:\n   Property Default Description     s3.sse.type none none, s3, kms or custom   s3.sse.key aws/s3 for kms type, null otherwise A KMS Key ID or ARN for kms type, or a custom base-64 AES256 symmetric key for custom type.   s3.sse.md5 null If SSE type is custom, this value must be set as the base-64 MD5 digest of the symmetric key to ensure integrity.    S3 Access Control List #  S3FileIO supports S3 access control list (ACL) for detailed access control. User can choose the ACL level by setting the s3.acl property. For more details, please read S3 ACL Documentation.\nObject Store File Layout #  S3 and many other cloud storage services throttle requests based on object prefix. Data stored in S3 with a traditional Hive storage layout can face S3 request throttling as objects are stored under the same filepath prefix.\nIceberg by default uses the Hive storage layout, but can be switched to use the ObjectStoreLocationProvider. With ObjectStoreLocationProvider, a determenistic hash is generated for each stored file, with the hash appended directly after the write.data.path. This ensures files written to s3 are equally distributed across multiple prefixes in the S3 bucket. Resulting in minimized throttling and maximized throughput for S3-related IO operations. When using ObjectStoreLocationProvider having a shared and short write.data.path across your Iceberg tables will improve performance.\nFor more information on how S3 scales API QPS, checkout the 2018 re:Invent session on Best Practices for Amazon S3 and Amazon S3 Glacier. At 53:39 it covers how S3 scales/partitions \u0026amp; at 54:50 it discusses the 30-60 minute wait time before new partitions are created.\nTo use the ObjectStorageLocationProvider add 'write.object-storage.enabled'=true in the table\u0026rsquo;s properties. Below is an example Spark SQL command to create a table using the ObjectStorageLocationProvider:\nCREATE TABLE my_catalog.my_ns.my_table ( id bigint, data string, category string) USING iceberg OPTIONS ( \u0026#39;write.object-storage.enabled\u0026#39;=true, \u0026#39;write.data.path\u0026#39;=\u0026#39;s3://my-table-data-bucket\u0026#39;) PARTITIONED BY (category); We can then insert a single row into this new table\nINSERT INTO my_catalog.my_ns.my_table VALUES (1, \u0026#34;Pizza\u0026#34;, \u0026#34;orders\u0026#34;); Which will write the data to S3 with a hash (2d3905f8) appended directly after the write.object-storage.path, ensuring reads to the table are spread evenly across S3 bucket prefixes, and improving performance.\ns3://my-table-data-bucket/2d3905f8/my_ns.db/my_table/category=orders/00000-0-5affc076-96a4-48f2-9cd2-d5efbc9f0c94-00001.parquet Note, the path resolution logic for ObjectStoreLocationProvider is write.data.path then \u0026lt;tableLocation\u0026gt;/data. However, for the older versions up to 0.12.0, the logic is as follows:\n before 0.12.0, write.object-storage.path must be set. at 0.12.0, write.object-storage.path then write.folder-storage.path then \u0026lt;tableLocation\u0026gt;/data.  For more details, please refer to the LocationProvider Configuration section.\nS3 Strong Consistency #  In November 2020, S3 announced strong consistency for all read operations, and Iceberg is updated to fully leverage this feature. There is no redundant consistency wait and check which might negatively impact performance during IO operations.\nHadoop S3A FileSystem #  Before S3FileIO was introduced, many Iceberg users choose to use HadoopFileIO to write data to S3 through the S3A FileSystem. As introduced in the previous sections, S3FileIO adopts latest AWS clients and S3 features for optimized security and performance, and is thus recommend for S3 use cases rather than the S3A FileSystem.\nS3FileIO writes data with s3:// URI scheme, but it is also compatible with schemes written by the S3A FileSystem. This means for any table manifests containing s3a:// or s3n:// file paths, S3FileIO is still able to read them. This feature allows people to easily switch from S3A to S3FileIO.\nIf for any reason you have to use S3A, here are the instructions:\n To store data using S3A, specify the warehouse catalog property to be an S3A path, e.g. s3a://my-bucket/my-warehouse For HiveCatalog, to also store metadata using S3A, specify the Hadoop config property hive.metastore.warehouse.dir to be an S3A path. Add hadoop-aws as a runtime dependency of your compute engine. Configure AWS settings based on hadoop-aws documentation (make sure you check the version, S3A configuration varies a lot based on the version you use).  S3 Write Checksum Verification #  To ensure integrity of uploaded objects, checksum validations for S3 writes can be turned on by setting catalog property s3.checksum-enabled to true. This is turned off by default.\nAWS Client Customization #  Many organizations have customized their way of configuring AWS clients with their own credential provider, access proxy, retry strategy, etc. Iceberg allows users to plug in their own implementation of org.apache.iceberg.aws.AwsClientFactory by setting the client.factory catalog property.\nCross-Account and Cross-Region Access #  It is a common use case for organizations to have a centralized AWS account for Glue metastore and S3 buckets, and use different AWS accounts and regions for different teams to access those resources. In this case, a cross-account IAM role is needed to access those centralized resources. Iceberg provides an AWS client factory AssumeRoleAwsClientFactory to support this common use case. This also serves as an example for users who would like to implement their own AWS client factory.\nThis client factory has the following configurable catalog properties:\n   Property Default Description     client.assume-role.arn null, requires user input ARN of the role to assume, e.g. arn:aws:iam::123456789:role/myRoleToAssume   client.assume-role.region null, requires user input All AWS clients except the STS client will use the given region instead of the default region chain   client.assume-role.external-id null An optional external ID   client.assume-role.timeout-sec 1 hour Timeout of each assume role session. At the end of the timeout, a new set of role session credentials will be fetched through a STS client.    By using this client factory, an STS client is initialized with the default credential and region to assume the specified role. The Glue, S3 and DynamoDB clients are then initialized with the assume-role credential and region to access resources. Here is an example to start Spark shell with this client factory:\nspark-sql --packages org.apache.iceberg:iceberg-spark3-runtime:0.13.0,software.amazon.awssdk:bundle:2.15.40 \\  --conf spark.sql.catalog.my_catalog=org.apache.iceberg.spark.SparkCatalog \\  --conf spark.sql.catalog.my_catalog.warehouse=s3://my-bucket/my/key/prefix \\  --conf spark.sql.catalog.my_catalog.catalog-impl=org.apache.iceberg.aws.glue.GlueCatalog \\  --conf spark.sql.catalog.my_catalog.client.factory=org.apache.iceberg.aws.AssumeRoleAwsClientFactory \\  --conf spark.sql.catalog.my_catalog.client.assume-role.arn=arn:aws:iam::123456789:role/myRoleToAssume \\  --conf spark.sql.catalog.my_catalog.client.assume-role.region=ap-northeast-1 Run Iceberg on AWS #  Amazon Athena #  Amazon Athena provides a serverless query engine that could be used to perform read, write, update and optimization tasks against Iceberg tables. More details could be found here.\nAmazon EMR #  Amazon EMR can provision clusters with Spark (EMR 6 for Spark 3, EMR 5 for Spark 2), Hive, Flink, Trino that can run Iceberg.\nStarting with EMR version 6.5.0, EMR clusters can be configured to have the necessary Apache Iceberg dependencies installed without requiring bootstrap actions. Please refer to the official documentation on how to create a cluster with Iceberg installed.\nFor versions before 6.5.0, you can use a bootstrap action similar to the following to pre-install all necessary dependencies:\n#!/bin/bash  AWS_SDK_VERSION=2.15.40 ICEBERG_VERSION=0.13.0 MAVEN_URL=https://repo1.maven.org/maven2 ICEBERG_MAVEN_URL=$MAVEN_URL/org/apache/iceberg AWS_MAVEN_URL=$MAVEN_URL/software/amazon/awssdk # NOTE: this is just an example shared class path between Spark and Flink, # please choose a proper class path for production. LIB_PATH=/usr/share/aws/aws-java-sdk/ AWS_PACKAGES=( \u0026#34;bundle\u0026#34; \u0026#34;url-connection-client\u0026#34; ) ICEBERG_PACKAGES=( \u0026#34;iceberg-spark3-runtime\u0026#34; \u0026#34;iceberg-flink-runtime\u0026#34; ) install_dependencies () { install_path=$1 download_url=$2 version=$3 shift pkgs=(\u0026#34;$@\u0026#34;) for pkg in \u0026#34;${pkgs[@]}\u0026#34;; do sudo wget -P $install_path $download_url/$pkg/$version/$pkg-$version.jar done } install_dependencies $LIB_PATH $ICEBERG_MAVEN_URL $ICEBERG_VERSION \u0026#34;${ICEBERG_PACKAGES[@]}\u0026#34; install_dependencies $LIB_PATH $AWS_MAVEN_URL $AWS_SDK_VERSION \u0026#34;${AWS_PACKAGES[@]}\u0026#34; AWS EKS #  AWS Elastic Kubernetes Service (EKS) can be used to start any Spark, Flink, Hive, Presto or Trino clusters to work with Iceberg. Search the Iceberg blogs page for tutorials around running Iceberg with Docker and Kubernetes.\nAmazon Kinesis #  Amazon Kinesis Data Analytics provides a platform to run fully managed Apache Flink applications. You can include Iceberg in your application Jar and run it in the platform.\n"},{"id":28,"href":"/docs/0.13.0/spark-configuration/","title":"Configuration","section":"Spark","content":"Spark Configuration #  Catalogs #  Spark 3.0 adds an API to plug in table catalogs that are used to load, create, and manage Iceberg tables. Spark catalogs are configured by setting Spark properties under spark.sql.catalog.\nThis creates an Iceberg catalog named hive_prod that loads tables from a Hive metastore:\nspark.sql.catalog.hive_prod = org.apache.iceberg.spark.SparkCatalog spark.sql.catalog.hive_prod.type = hive spark.sql.catalog.hive_prod.uri = thrift://metastore-host:port # omit uri to use the same URI as Spark: hive.metastore.uris in hive-site.xml Iceberg also supports a directory-based catalog in HDFS that can be configured using type=hadoop:\nspark.sql.catalog.hadoop_prod = org.apache.iceberg.spark.SparkCatalog spark.sql.catalog.hadoop_prod.type = hadoop spark.sql.catalog.hadoop_prod.warehouse = hdfs://nn:8020/warehouse/path The Hive-based catalog only loads Iceberg tables. To load non-Iceberg tables in the same Hive metastore, use a session catalog.  Catalog configuration #  A catalog is created and named by adding a property spark.sql.catalog.(catalog-name) with an implementation class for its value.\nIceberg supplies two implementations:\n org.apache.iceberg.spark.SparkCatalog supports a Hive Metastore or a Hadoop warehouse as a catalog org.apache.iceberg.spark.SparkSessionCatalog adds support for Iceberg tables to Spark\u0026rsquo;s built-in catalog, and delegates to the built-in catalog for non-Iceberg tables  Both catalogs are configured using properties nested under the catalog name. Common configuration properties for Hive and Hadoop are:\n   Property Values Description     spark.sql.catalog.catalog-name.type hive or hadoop The underlying Iceberg catalog implementation, HiveCatalog, HadoopCatalog or left unset if using a custom catalog   spark.sql.catalog.catalog-name.catalog-impl  The underlying Iceberg catalog implementation.   spark.sql.catalog.catalog-name.default-namespace default The default current namespace for the catalog   spark.sql.catalog.catalog-name.uri thrift://host:port Metastore connect URI; default from hive-site.xml   spark.sql.catalog.catalog-name.warehouse hdfs://nn:8020/warehouse/path Base path for the warehouse directory   spark.sql.catalog.catalog-name.cache-enabled true or false Whether to enable catalog cache, default value is true   spark.sql.catalog.catalog-name.cache.expiration-interval-ms 30000 (30 seconds) Duration after which cached catalog entries are expired; Only effective if cache-enabled is true. -1 disables cache expiration and 0 disables caching entirely, irrespective of cache-enabled. Default is 30000 (30 seconds)    Additional properties can be found in common catalog configuration.\nUsing catalogs #  Catalog names are used in SQL queries to identify a table. In the examples above, hive_prod and hadoop_prod can be used to prefix database and table names that will be loaded from those catalogs.\nSELECT * FROM hive_prod.db.table -- load db.table from catalog hive_prod Spark 3 keeps track of the current catalog and namespace, which can be omitted from table names.\nUSE hive_prod.db; SELECT * FROM table -- load db.table from catalog hive_prod To see the current catalog and namespace, run SHOW CURRENT NAMESPACE.\nReplacing the session catalog #  To add Iceberg table support to Spark\u0026rsquo;s built-in catalog, configure spark_catalog to use Iceberg\u0026rsquo;s SparkSessionCatalog.\nspark.sql.catalog.spark_catalog = org.apache.iceberg.spark.SparkSessionCatalog spark.sql.catalog.spark_catalog.type = hive Spark\u0026rsquo;s built-in catalog supports existing v1 and v2 tables tracked in a Hive Metastore. This configures Spark to use Iceberg\u0026rsquo;s SparkSessionCatalog as a wrapper around that session catalog. When a table is not an Iceberg table, the built-in catalog will be used to load it instead.\nThis configuration can use same Hive Metastore for both Iceberg and non-Iceberg tables.\nUsing catalog specific Hadoop configuration values #  Similar to configuring Hadoop properties by using spark.hadoop.*, it\u0026rsquo;s possible to set per-catalog Hadoop configuration values when using Spark by adding the property for the catalog with the prefix spark.sql.catalog.(catalog-name).hadoop.*. These properties will take precedence over values configured globally using spark.hadoop.* and will only affect Iceberg tables.\nspark.sql.catalog.hadoop_prod.hadoop.fs.s3a.endpoint = http://aws-local:9000 Loading a custom catalog #  Spark supports loading a custom Iceberg Catalog implementation by specifying the catalog-impl property. Here is an example:\nspark.sql.catalog.custom_prod = org.apache.iceberg.spark.SparkCatalog spark.sql.catalog.custom_prod.catalog-impl = com.my.custom.CatalogImpl spark.sql.catalog.custom_prod.my-additional-catalog-config = my-value Catalogs in Spark 2.4 #  When using Iceberg 0.11.0 and later, Spark 2.4 can load tables from multiple Iceberg catalogs or from table locations.\nCatalogs in 2.4 are configured just like catalogs in 3.0, but only Iceberg catalogs are supported.\nSQL Extensions #  Iceberg 0.11.0 and later add an extension module to Spark to add new SQL commands, like CALL for stored procedures or ALTER TABLE ... WRITE ORDERED BY.\nUsing those SQL commands requires adding Iceberg extensions to your Spark environment using the following Spark property:\n   Spark extensions property Iceberg extensions implementation     spark.sql.extensions org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions    SQL extensions are not available for Spark 2.4.\nRuntime configuration #  Read options #  Spark read options are passed when configuring the DataFrameReader, like this:\n// time travel spark.read .option(\u0026#34;snapshot-id\u0026#34;, 10963874102873L) .table(\u0026#34;catalog.db.table\u0026#34;)    Spark option Default Description     snapshot-id (latest) Snapshot ID of the table snapshot to read   as-of-timestamp (latest) A timestamp in milliseconds; the snapshot used will be the snapshot current at this time.   split-size As per table property Overrides this table\u0026rsquo;s read.split.target-size and read.split.metadata-target-size   lookback As per table property Overrides this table\u0026rsquo;s read.split.planning-lookback   file-open-cost As per table property Overrides this table\u0026rsquo;s read.split.open-file-cost   vectorization-enabled As per table property Overrides this table\u0026rsquo;s read.parquet.vectorization.enabled   batch-size As per table property Overrides this table\u0026rsquo;s read.parquet.vectorization.batch-size   stream-from-timestamp (none) A timestamp in milliseconds to stream from; if before the oldest known ancestor snapshot, the oldest will be used    Write options #  Spark write options are passed when configuring the DataFrameWriter, like this:\n// write with Avro instead of Parquet df.write .option(\u0026#34;write-format\u0026#34;, \u0026#34;avro\u0026#34;) .option(\u0026#34;snapshot-property.key\u0026#34;, \u0026#34;value\u0026#34;) .insertInto(\u0026#34;catalog.db.table\u0026#34;)    Spark option Default Description     write-format Table write.format.default File format to use for this write operation; parquet, avro, or orc   target-file-size-bytes As per table property Overrides this table\u0026rsquo;s write.target-file-size-bytes   check-nullability true Sets the nullable check on fields   snapshot-property.custom-key null Adds an entry with custom-key and corresponding value in the snapshot summary   fanout-enabled false Overrides this table\u0026rsquo;s write.spark.fanout.enabled   check-ordering true Checks if input schema and table schema are same    "},{"id":29,"href":"/docs/0.13.0/spark-ddl/","title":"DDL","section":"Spark","content":"Spark DDL #  To use Iceberg in Spark, first configure Spark catalogs.\nIceberg uses Apache Spark\u0026rsquo;s DataSourceV2 API for data source and catalog implementations. Spark DSv2 is an evolving API with different levels of support in Spark versions. Spark 2.4 does not support SQL DDL.\nSpark 2.4 can\u0026rsquo;t create Iceberg tables with DDL, instead use Spark 3.x or the Iceberg API.  CREATE TABLE #  Spark 3.0 can create tables in any Iceberg catalog with the clause USING iceberg:\nCREATE TABLE prod.db.sample ( id bigint COMMENT \u0026#39;unique id\u0026#39;, data string) USING iceberg Iceberg will convert the column type in Spark to corresponding Iceberg type. Please check the section of type compatibility on creating table for details.\nTable create commands, including CTAS and RTAS, support the full range of Spark create clauses, including:\n PARTITION BY (partition-expressions) to configure partitioning LOCATION '(fully-qualified-uri)' to set the table location COMMENT 'table documentation' to set a table description TBLPROPERTIES ('key'='value', ...) to set table configuration  Create commands may also set the default format with the USING clause. This is only supported for SparkCatalog because Spark handles the USING clause differently for the built-in catalog.\nPARTITIONED BY #  To create a partitioned table, use PARTITIONED BY:\nCREATE TABLE prod.db.sample ( id bigint, data string, category string) USING iceberg PARTITIONED BY (category) The PARTITIONED BY clause supports transform expressions to create hidden partitions.\nCREATE TABLE prod.db.sample ( id bigint, data string, category string, ts timestamp) USING iceberg PARTITIONED BY (bucket(16, id), days(ts), category) Supported transformations are:\n years(ts): partition by year months(ts): partition by month days(ts) or date(ts): equivalent to dateint partitioning hours(ts) or date_hour(ts): equivalent to dateint and hour partitioning bucket(N, col): partition by hashed value mod N buckets truncate(L, col): partition by value truncated to L  Strings are truncated to the given length Integers and longs truncate to bins: truncate(10, i) produces partitions 0, 10, 20, 30, \u0026hellip;    CREATE TABLE ... AS SELECT #  Iceberg supports CTAS as an atomic operation when using a SparkCatalog. CTAS is supported, but is not atomic when using SparkSessionCatalog.\nCREATE TABLE prod.db.sample USING iceberg AS SELECT ... REPLACE TABLE ... AS SELECT #  Iceberg supports RTAS as an atomic operation when using a SparkCatalog. RTAS is supported, but is not atomic when using SparkSessionCatalog.\nAtomic table replacement creates a new snapshot with the results of the SELECT query, but keeps table history.\nREPLACE TABLE prod.db.sample USING iceberg AS SELECT ... REPLACE TABLE prod.db.sample USING iceberg PARTITIONED BY (part) TBLPROPERTIES (\u0026#39;key\u0026#39;=\u0026#39;value\u0026#39;) AS SELECT ... CREATE OR REPLACE TABLE prod.db.sample USING iceberg AS SELECT ... The schema and partition spec will be replaced if changed. To avoid modifying the table\u0026rsquo;s schema and partitioning, use INSERT OVERWRITE instead of REPLACE TABLE. The new table properties in the REPLACE TABLE command will be merged with any existing table properties. The existing table properties will be updated if changed else they are preserved.\nDROP TABLE #  To delete a table, run:\nDROP TABLE prod.db.sample ALTER TABLE #  Iceberg has full ALTER TABLE support in Spark 3, including:\n Renaming a table Setting or removing table properties Adding, deleting, and renaming columns Adding, deleting, and renaming nested fields Reordering top-level columns and nested struct fields Widening the type of int, float, and decimal fields Making required columns optional  In addition, SQL extensions can be used to add support for partition evolution and setting a table\u0026rsquo;s write order\nALTER TABLE ... RENAME TO #  ALTER TABLE prod.db.sample RENAME TO prod.db.new_name ALTER TABLE ... SET TBLPROPERTIES #  ALTER TABLE prod.db.sample SET TBLPROPERTIES ( \u0026#39;read.split.target-size\u0026#39;=\u0026#39;268435456\u0026#39; ) Iceberg uses table properties to control table behavior. For a list of available properties, see Table configuration.\nUNSET is used to remove properties:\nALTER TABLE prod.db.sample UNSET TBLPROPERTIES (\u0026#39;read.split.target-size\u0026#39;) ALTER TABLE ... ADD COLUMN #  To add a column to Iceberg, use the ADD COLUMNS clause with ALTER TABLE:\nALTER TABLE prod.db.sample ADD COLUMNS ( new_column string comment \u0026#39;new_column docs\u0026#39; ) Multiple columns can be added at the same time, separated by commas.\nNested columns should be identified using the full column name:\n-- create a struct column ALTER TABLE prod.db.sample ADD COLUMN point struct\u0026lt;x: double, y: double\u0026gt;; -- add a field to the struct ALTER TABLE prod.db.sample ADD COLUMN point.z double -- create a nested array column of struct ALTER TABLE prod.db.sample ADD COLUMN points array\u0026lt;struct\u0026lt;x: double, y: double\u0026gt;\u0026gt;; -- add a field to the struct within an array. Using keyword \u0026#39;element\u0026#39; to access the array\u0026#39;s element column. ALTER TABLE prod.db.sample ADD COLUMN points.element.z double -- create a map column of struct key and struct value ALTER TABLE prod.db.sample ADD COLUMN points map\u0026lt;struct\u0026lt;x: int\u0026gt;, struct\u0026lt;a: int\u0026gt;\u0026gt;; -- add a field to the value struct in a map. Using keyword \u0026#39;value\u0026#39; to access the map\u0026#39;s value column. ALTER TABLE prod.db.sample ADD COLUMN points.value.b int Note: Altering a map \u0026lsquo;key\u0026rsquo; column by adding columns is not allowed. Only map values can be updated.\nIn Spark 2.4.4 and later, you can add columns in any position by adding FIRST or AFTER clauses:\nALTER TABLE prod.db.sample ADD COLUMN new_column bigint AFTER other_column ALTER TABLE prod.db.sample ADD COLUMN nested.new_column bigint FIRST ALTER TABLE ... RENAME COLUMN #  Iceberg allows any field to be renamed. To rename a field, use RENAME COLUMN:\nALTER TABLE prod.db.sample RENAME COLUMN data TO payload ALTER TABLE prod.db.sample RENAME COLUMN location.lat TO latitude Note that nested rename commands only rename the leaf field. The above command renames location.lat to location.latitude\nALTER TABLE ... ALTER COLUMN #  Alter column is used to widen types, make a field optional, set comments, and reorder fields.\nIceberg allows updating column types if the update is safe. Safe updates are:\n int to bigint float to double decimal(P,S) to decimal(P2,S) when P2 \u0026gt; P (scale cannot change)  ALTER TABLE prod.db.sample ALTER COLUMN measurement TYPE double To add or remove columns from a struct, use ADD COLUMN or DROP COLUMN with a nested column name.\nColumn comments can also be updated using ALTER COLUMN:\nALTER TABLE prod.db.sample ALTER COLUMN measurement TYPE double COMMENT \u0026#39;unit is bytes per second\u0026#39; ALTER TABLE prod.db.sample ALTER COLUMN measurement COMMENT \u0026#39;unit is kilobytes per second\u0026#39; Iceberg allows reordering top-level columns or columns in a struct using FIRST and AFTER clauses:\nALTER TABLE prod.db.sample ALTER COLUMN col FIRST ALTER TABLE prod.db.sample ALTER COLUMN nested.col AFTER other_col Nullability can be changed using SET NOT NULL and DROP NOT NULL:\nALTER TABLE prod.db.sample ALTER COLUMN id DROP NOT NULL ALTER COLUMN is not used to update struct types. Use ADD COLUMN and DROP COLUMN to add or remove struct fields.  ALTER TABLE ... DROP COLUMN #  To drop columns, use ALTER TABLE ... DROP COLUMN:\nALTER TABLE prod.db.sample DROP COLUMN id ALTER TABLE prod.db.sample DROP COLUMN point.z ALTER TABLE SQL extensions #  These commands are available in Spark 3.x when using Iceberg SQL extensions.\nALTER TABLE ... ADD PARTITION FIELD #  Iceberg supports adding new partition fields to a spec using ADD PARTITION FIELD:\nALTER TABLE prod.db.sample ADD PARTITION FIELD catalog -- identity transform Partition transforms are also supported:\nALTER TABLE prod.db.sample ADD PARTITION FIELD bucket(16, id) ALTER TABLE prod.db.sample ADD PARTITION FIELD truncate(data, 4) ALTER TABLE prod.db.sample ADD PARTITION FIELD years(ts) -- use optional AS keyword to specify a custom name for the partition field ALTER TABLE prod.db.sample ADD PARTITION FIELD bucket(16, id) AS shard Adding a partition field is a metadata operation and does not change any of the existing table data. New data will be written with the new partitioning, but existing data will remain in the old partition layout. Old data files will have null values for the new partition fields in metadata tables.\nDynamic partition overwrite behavior will change when the table\u0026rsquo;s partitioning changes because dynamic overwrite replaces partitions implicitly. To overwrite explicitly, use the new DataFrameWriterV2 API.\nTo migrate from daily to hourly partitioning with transforms, it is not necessary to drop the daily partition field. Keeping the field ensures existing metadata table queries continue to work.  Dynamic partition overwrite behavior will change when partitioning changes For example, if you partition by days and move to partitioning by hours, overwrites will overwrite hourly partitions but not days anymore.  ALTER TABLE ... DROP PARTITION FIELD #  Partition fields can be removed using DROP PARTITION FIELD:\nALTER TABLE prod.db.sample DROP PARTITION FIELD catalog ALTER TABLE prod.db.sample DROP PARTITION FIELD bucket(16, id) ALTER TABLE prod.db.sample DROP PARTITION FIELD truncate(data, 4) ALTER TABLE prod.db.sample DROP PARTITION FIELD years(ts) ALTER TABLE prod.db.sample DROP PARTITION FIELD shard Note that although the partition is removed, the column will still exist in the table schema.\nDropping a partition field is a metadata operation and does not change any of the existing table data. New data will be written with the new partitioning, but existing data will remain in the old partition layout.\nDynamic partition overwrite behavior will change when partitioning changes For example, if you partition by days and move to partitioning by hours, overwrites will overwrite hourly partitions but not days anymore.  Be careful when dropping a partition field because it will change the schema of metadata tables, like files, and may cause metadata queries to fail or produce different results.  ALTER TABLE ... WRITE ORDERED BY #  Iceberg tables can be configured with a sort order that is used to automatically sort data that is written to the table in some engines. For example, MERGE INTO in Spark will use the table ordering.\nTo set the write order for a table, use WRITE ORDERED BY:\nALTER TABLE prod.db.sample WRITE ORDERED BY category, id -- use optional ASC/DEC keyword to specify sort order of each field (default ASC) ALTER TABLE prod.db.sample WRITE ORDERED BY category ASC, id DESC -- use optional NULLS FIRST/NULLS LAST keyword to specify null order of each field (default FIRST) ALTER TABLE prod.db.sample WRITE ORDERED BY category ASC NULLS LAST, id DESC NULLS FIRST Table write order does not guarantee data order for queries. It only affects how data is written to the table.  WRITE ORDERED BY sets a global ordering where rows are ordered across tasks, like using ORDER BY in an INSERT command:\nINSERT INTO prod.db.sample SELECT id, data, category, ts FROM another_table ORDER BY ts, category To order within each task, not across tasks, use LOCALLY ORDERED BY:\nALTER TABLE prod.db.sample WRITE LOCALLY ORDERED BY category, id ALTER TABLE ... WRITE DISTRIBUTED BY PARTITION #  WRITE DISTRIBUTED BY PARTITION will request that each partition is handled by one writer, the default implementation is hash distribution.\nALTER TABLE prod.db.sample WRITE DISTRIBUTED BY PARTITION DISTRIBUTED BY PARTITION and LOCALLY ORDERED BY may be used together, to distribute by partition and locally order rows within each task.\nALTER TABLE prod.db.sample WRITE DISTRIBUTED BY PARTITION LOCALLY ORDERED BY category, id "},{"id":30,"href":"/docs/0.13.0/jdbc/","title":"JDBC","section":"Integrations","content":"Iceberg JDBC Integration #  JDBC Catalog #  Iceberg supports using a table in a relational database to manage Iceberg tables through JDBC. The database that JDBC connects to must support atomic transaction to allow the JDBC catalog implementation to properly support atomic Iceberg table commits and read serializable isolation.\nConfigurations #  Because each database and database service provider might require different configurations, the JDBC catalog allows arbitrary configurations through:\n   Property Default Description     uri  the JDBC connection string   jdbc.\u0026lt;property_key\u0026gt;  any key value pairs to configure the JDBC connection    Examples #  Spark #  You can start a Spark session with a MySQL JDBC connection using the following configurations:\nspark-sql --packages org.apache.iceberg:iceberg-spark3-runtime:0.13.0 \\  --conf spark.sql.catalog.my_catalog=org.apache.iceberg.spark.SparkCatalog \\  --conf spark.sql.catalog.my_catalog.warehouse=s3://my-bucket/my/key/prefix \\  --conf spark.sql.catalog.my_catalog.catalog-impl=org.apache.iceberg.jdbc.JdbcCatalog \\  --conf spark.sql.catalog.my_catalog.uri=jdbc:mysql://test.1234567890.us-west-2.rds.amazonaws.com:3306/default \\  --conf spark.sql.catalog.my_catalog.jdbc.verifyServerCertificate=true \\  --conf spark.sql.catalog.my_catalog.jdbc.useSSL=true \\  --conf spark.sql.catalog.my_catalog.jdbc.user=admin \\  --conf spark.sql.catalog.my_catalog.jdbc.password=pass Java API #  Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); // ensure JDBC driver is at runtime classpath Map\u0026lt;String, String\u0026gt; properties = new HashMap\u0026lt;\u0026gt;(); properties.put(CatalogProperties.CATALOG_IMPL, JdbcCatalog.class.getName()); properties.put(CatalogProperties.URI, \u0026#34;jdbc:mysql://localhost:3306/test\u0026#34;); properties.put(JdbcCatalog.PROPERTY_PREFIX + \u0026#34;user\u0026#34;, \u0026#34;admin\u0026#34;); properties.put(JdbcCatalog.PROPERTY_PREFIX + \u0026#34;password\u0026#34;, \u0026#34;pass\u0026#34;); properties.put(CatalogProperties.WAREHOUSE_LOCATION, \u0026#34;s3://warehouse/path\u0026#34;); Configuration hadoopConf = new Configuration(); // configs if you use HadoopFileIO JdbcCatalog catalog = CatalogUtil.buildIcebergCatalog(\u0026#34;test_jdbc_catalog\u0026#34;, properties, hadoopConf); "},{"id":31,"href":"/docs/0.13.0/nessie/","title":"Nessie","section":"Integrations","content":"Iceberg Nessie Integration #  Iceberg provides integration with Nessie through the iceberg-nessie module. This section describes how to use Iceberg with Nessie. Nessie provides several key features on top of Iceberg:\n multi-table transactions git-like operations (eg branches, tags, commits) hive-like metastore capabilities  See Project Nessie for more information on Nessie. Nessie requires a server to run, see Getting Started to start a Nessie server.\nEnabling Nessie Catalog #  The iceberg-nessie module is bundled with Spark and Flink runtimes for all versions from 0.11.0. To get started with Nessie and Iceberg simply add the Iceberg runtime to your process. Eg: spark-sql --packages org.apache.iceberg:iceberg-spark3-runtime:0.13.0.\nSpark SQL Extensions #  From spark, Nessie SQL extensions can be used to manage the Nessie repo as shown below.\nbin/spark-sql --packages \u0026quot;org.apache.iceberg:iceberg-spark3-runtime:0.13.0,org.projectnessie:nessie-spark-extensions:0.18.0\u0026quot; --conf spark.sql.extensions=\u0026quot;org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions,org.projectnessie.spark.extensions.NessieSparkSessionExtensions\u0026quot; --conf \u0026lt;other settings\u0026gt; Please refer Nessie SQL extension document to learn more about it.\nNessie Catalog #  One major feature introduced in release 0.11.0 is the ability to easily interact with a Custom Catalog from Spark and Flink. See Spark Configuration and Flink Configuration for instructions for adding a custom catalog to Iceberg.\nTo use the Nessie Catalog the following properties are required:\n warehouse. Like most other catalogs the warehouse property is a file path to where this catalog should store tables. uri. This is the Nessie server base uri. Eg http://localhost:19120/api/v1. ref (optional). This is the Nessie branch or tag you want to work in.  To run directly in Java this looks like:\nMap\u0026lt;String, String\u0026gt; options = new HashMap\u0026lt;\u0026gt;(); options.put(\u0026#34;warehouse\u0026#34;, \u0026#34;/path/to/warehouse\u0026#34;); options.put(\u0026#34;ref\u0026#34;, \u0026#34;main\u0026#34;); options.put(\u0026#34;uri\u0026#34;, \u0026#34;https://localhost:19120/api/v1\u0026#34;); Catalog nessieCatalog = CatalogUtil.loadCatalog(\u0026#34;org.apache.iceberg.nessie.NessieCatalog\u0026#34;, \u0026#34;nessie\u0026#34;, hadoopConfig, options); and in Spark:\nconf.set(\u0026#34;spark.sql.catalog.nessie.warehouse\u0026#34;, \u0026#34;/path/to/warehouse\u0026#34;); conf.set(\u0026#34;spark.sql.catalog.nessie.uri\u0026#34;, \u0026#34;http://localhost:19120/api/v1\u0026#34;) conf.set(\u0026#34;spark.sql.catalog.nessie.ref\u0026#34;, \u0026#34;main\u0026#34;) conf.set(\u0026#34;spark.sql.catalog.nessie.catalog-impl\u0026#34;, \u0026#34;org.apache.iceberg.nessie.NessieCatalog\u0026#34;) conf.set(\u0026#34;spark.sql.catalog.nessie\u0026#34;, \u0026#34;org.apache.iceberg.spark.SparkCatalog\u0026#34;) conf.set(\u0026#34;spark.sql.extensions\u0026#34;, \u0026#34;org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions,org.projectnessie.spark.extensions.NessieSparkSessionExtensions\u0026#34;) This is how it looks in Flink via the Python API (additional details can be found here):\nimport os from pyflink.datastream import StreamExecutionEnvironment from pyflink.table import StreamTableEnvironment env = StreamExecutionEnvironment.get_execution_environment() iceberg_flink_runtime_jar = os.path.join(os.getcwd(), \u0026#34;iceberg-flink-runtime-0.13.0.jar\u0026#34;) env.add_jars(\u0026#34;file://{}\u0026#34;.format(iceberg_flink_runtime_jar)) table_env = StreamTableEnvironment.create(env) table_env.execute_sql(\u0026#34;CREATE CATALOG nessie_catalog WITH (\u0026#34; \u0026#34;\u0026#39;type\u0026#39;=\u0026#39;iceberg\u0026#39;, \u0026#34; \u0026#34;\u0026#39;catalog-impl\u0026#39;=\u0026#39;org.apache.iceberg.nessie.NessieCatalog\u0026#39;, \u0026#34; \u0026#34;\u0026#39;uri\u0026#39;=\u0026#39;http://localhost:19120/api/v1\u0026#39;, \u0026#34; \u0026#34;\u0026#39;ref\u0026#39;=\u0026#39;main\u0026#39;, \u0026#34; \u0026#34;\u0026#39;warehouse\u0026#39;=\u0026#39;/path/to/warehouse\u0026#39;)\u0026#34;) There is nothing special above about the nessie name. A spark catalog can have any name, the important parts are the settings for the catalog-impl and the required config to start Nessie correctly. Once you have a Nessie catalog you have access to your entire Nessie repo. You can then perform create/delete/merge operations on branches and perform commits on branches. Each Iceberg table in a Nessie Catalog is identified by an arbitrary length namespace and table name (eg data.base.name.table). These namespaces are implicit and don\u0026rsquo;t need to be created separately. Any transaction on a Nessie enabled Iceberg table is a single commit in Nessie. Nessie commits can encompass an arbitrary number of actions on an arbitrary number of tables, however in Iceberg this will be limited to the set of single table transactions currently available.\nFurther operations such as merges, viewing the commit log or diffs are performed by direct interaction with the NessieClient in java or by using the python client or cli. See Nessie CLI for more details on the CLI and Spark Guide for a more complete description of Nessie functionality.\nNessie and Iceberg #  For most cases Nessie acts just like any other Catalog for Iceberg: providing a logical organization of a set of tables and providing atomicity to transactions. However, using Nessie opens up other interesting possibilities. When using Nessie with Iceberg every Iceberg transaction becomes a Nessie commit. This history can be listed, merged or cherry-picked across branches.\nLoosely coupled transactions #  By creating a branch and performing a set of operations on that branch you can approximate a multi-table transaction. A sequence of commits can be performed on the newly created branch and then merged back into the main branch atomically. This gives the appearance of a series of connected changes being exposed to the main branch simultaneously. While downstream consumers will see multiple transactions appear at once this isn\u0026rsquo;t a true multi-table transaction on the database. It is effectively a fast-forward merge of multiple commits (in git language) and each operation from the branch is its own distinct transaction and commit. This is different from a real multi-table transaction where all changes would be in the same commit. This does allow multiple applications to take part in modifying a branch and for this distributed set of transactions to be exposed to the downstream users simultaneously.\nExperimentation #  Changes to a table can be tested in a branch before merging back into main. This is particularly useful when performing large changes like schema evolution or partition evolution. A partition evolution could be performed in a branch and you would be able to test out the change (eg performance benchmarks) before merging it. This provides great flexibility in performing on-line table modifications and testing without interrupting downstream use cases. If the changes are incorrect or not performant the branch can be dropped without being merged.\nFurther use cases #  Please see the Nessie Documentation for further descriptions of Nessie features.\nRegular table maintenance in Iceberg is complicated when using nessie. Please consult Management Services before performing any table maintenance.  Example #  Please have a look at the Nessie Demos repo for different examples of Nessie and Iceberg in action together.\nFuture Improvements #   Iceberg multi-table transactions. Changes to multiple Iceberg tables in the same transaction, isolation levels etc  "},{"id":32,"href":"/docs/0.13.0/spark-procedures/","title":"Procedures","section":"Spark","content":"Spark Procedures #  To use Iceberg in Spark, first configure Spark catalogs. Stored procedures are only available when using Iceberg SQL extensions in Spark 3.x.\nUsage #  Procedures can be used from any configured Iceberg catalog with CALL. All procedures are in the namespace system.\nCALL supports passing arguments by name (recommended) or by position. Mixing position and named arguments is not supported.\nNamed arguments #  All procedure arguments are named. When passing arguments by name, arguments can be in any order and any optional argument can be omitted.\nCALL catalog_name.system.procedure_name(arg_name_2 =\u0026gt; arg_2, arg_name_1 =\u0026gt; arg_1) Positional arguments #  When passing arguments by position, only the ending arguments may be omitted if they are optional.\nCALL catalog_name.system.procedure_name(arg_1, arg_2, ... arg_n) Snapshot management #  rollback_to_snapshot #  Roll back a table to a specific snapshot ID.\nTo roll back to a specific time, use rollback_to_timestamp.\nThis procedure invalidates all cached Spark plans that reference the affected table.  Usage #     Argument Name Required? Type Description     table ✔️ string Name of the table to update   snapshot_id ✔️ long Snapshot ID to rollback to    Output #     Output Name Type Description     previous_snapshot_id long The current snapshot ID before the rollback   current_snapshot_id long The new current snapshot ID    Example #  Roll back table db.sample to snapshot ID 1:\nCALL catalog_name.system.rollback_to_snapshot(\u0026#39;db.sample\u0026#39;, 1) rollback_to_timestamp #  Roll back a table to the snapshot that was current at some time.\nThis procedure invalidates all cached Spark plans that reference the affected table.  Usage #     Argument Name Required? Type Description     table ✔️ string Name of the table to update   timestamp ✔️ timestamp A timestamp to rollback to    Output #     Output Name Type Description     previous_snapshot_id long The current snapshot ID before the rollback   current_snapshot_id long The new current snapshot ID    Example #  Roll back db.sample to one day\nCALL catalog_name.system.rollback_to_timestamp(\u0026#39;db.sample\u0026#39;, TIMESTAMP \u0026#39;2021-06-30 00:00:00.000\u0026#39;) set_current_snapshot #  Sets the current snapshot ID for a table.\nUnlike rollback, the snapshot is not required to be an ancestor of the current table state.\nThis procedure invalidates all cached Spark plans that reference the affected table.  Usage #     Argument Name Required? Type Description     table ✔️ string Name of the table to update   snapshot_id ✔️ long Snapshot ID to set as current    Output #     Output Name Type Description     previous_snapshot_id long The current snapshot ID before the rollback   current_snapshot_id long The new current snapshot ID    Example #  Set the current snapshot for db.sample to 1:\nCALL catalog_name.system.set_current_snapshot(\u0026#39;db.sample\u0026#39;, 1) cherrypick_snapshot #  Cherry-picks changes from a snapshot into the current table state.\nCherry-picking creates a new snapshot from an existing snapshot without altering or removing the original.\nOnly append and dynamic overwrite snapshots can be cherry-picked.\nThis procedure invalidates all cached Spark plans that reference the affected table.  Usage #     Argument Name Required? Type Description     table ✔️ string Name of the table to update   snapshot_id ✔️ long The snapshot ID to cherry-pick    Output #     Output Name Type Description     source_snapshot_id long The table\u0026rsquo;s current snapshot before the cherry-pick   current_snapshot_id long The snapshot ID created by applying the cherry-pick    Examples #  Cherry-pick snapshot 1\nCALL catalog_name.system.cherrypick_snapshot(\u0026#39;my_table\u0026#39;, 1) Cherry-pick snapshot 1 with named args\nCALL catalog_name.system.cherrypick_snapshot(snapshot_id =\u0026gt; 1, table =\u0026gt; \u0026#39;my_table\u0026#39; ) Metadata management #  Many maintenance actions can be performed using Iceberg stored procedures.\nexpire_snapshots #  Each write/update/delete/upsert/compaction in Iceberg produces a new snapshot while keeping the old data and metadata around for snapshot isolation and time travel. The expire_snapshots procedure can be used to remove older snapshots and their files which are no longer needed.\nThis procedure will remove old snapshots and data files which are uniquely required by those old snapshots. This means the expire_snapshots procedure will never remove files which are still required by a non-expired snapshot.\nUsage #     Argument Name Required? Type Description     table ✔️ string Name of the table to update   older_than ️ timestamp Timestamp before which snapshots will be removed (Default: 5 days ago)   retain_last  int Number of ancestor snapshots to preserve regardless of older_than (defaults to 1)   max_concurrent_deletes  int Size of the thread pool used for delete file actions (by default, no thread pool is used)    If older_than and retain_last are omitted, the table\u0026rsquo;s expiration properties will be used.\nOutput #     Output Name Type Description     deleted_data_files_count long Number of data files deleted by this operation   deleted_manifest_files_count long Number of manifest files deleted by this operation   deleted_manifest_lists_count long Number of manifest List files deleted by this operation    Examples #  Remove snapshots older than one day, but retain the last 100 snapshots:\nCALL hive_prod.system.expire_snapshots(\u0026#39;db.sample\u0026#39;, TIMESTAMP \u0026#39;2021-06-30 00:00:00.000\u0026#39;, 100) Erase all snapshots older than the current timestamp but retain the last 5 snapshots:\nCALL hive_prod.system.expire_snapshots(table =\u0026gt; \u0026#39;db.sample\u0026#39;, older_than =\u0026gt; now(), retain_last =\u0026gt; 5) remove_orphan_files #  Used to remove files which are not referenced in any metadata files of an Iceberg table and can thus be considered \u0026ldquo;orphaned\u0026rdquo;.\nUsage #     Argument Name Required? Type Description     table ✔️ string Name of the table to clean   older_than ️ timestamp Remove orphan files created before this timestamp (Defaults to 3 days ago)   location  string Directory to look for files in (defaults to the table\u0026rsquo;s location)   dry_run  boolean When true, don\u0026rsquo;t actually remove files (defaults to false)   max_concurrent_deletes  int Size of the thread pool used for delete file actions (by default, no thread pool is used)    Output #     Output Name Type Description     orphan_file_location String The path to each file determined to be an orphan by this command    Examples #  List all the files that are candidates for removal by performing a dry run of the remove_orphan_files command on this table without actually removing them:\nCALL catalog_name.system.remove_orphan_files(table =\u0026gt; \u0026#39;db.sample\u0026#39;, dry_run =\u0026gt; true) Remove any files in the tablelocation/data folder which are not known to the table db.sample.\nCALL catalog_name.system.remove_orphan_files(table =\u0026gt; \u0026#39;db.sample\u0026#39;, location =\u0026gt; \u0026#39;tablelocation/data\u0026#39;) rewrite_data_files #  Iceberg tracks each data file in a table. More data files leads to more metadata stored in manifest files, and small data files causes an unnecessary amount of metadata and less efficient queries from file open costs.\nIceberg can compact data files in parallel using Spark with the rewriteDataFiles action. This will combine small files into larger files to reduce metadata overhead and runtime file open cost.\nUsage #     Argument Name Required? Type Description     table ✔️ string Name of the table to update   strategy  string Name of the strategy - binpack or sort. Defaults to binpack strategy   sort_order  string Comma separated sort_order_column. Where sort_order_column is a space separated sort order info per column (ColumnName SortDirection NullOrder). SortDirection can be ASC or DESC. NullOrder can be NULLS FIRST or NULLS LAST   options ️ map\u0026lt;string, string\u0026gt; Options to be used for actions   where ️ string predicate as a string used for filtering the files. Note that all files that may contain data matching the filter will be selected for rewriting    See the [RewriteDataFiles Javadoc](./javadoc/{{ versions.iceberg }}/org/apache/iceberg/actions/RewriteDataFiles.html#field.summary), [BinPackStrategy Javadoc](./javadoc/{{ versions.iceberg }}/org/apache/iceberg/actions/BinPackStrategy.html#field.summary) and [SortStrategy Javadoc](./javadoc/{{ versions.iceberg }}/org/apache/iceberg/actions/SortStrategy.html#field.summary) for list of all the supported options for this action.\nOutput #     Output Name Type Description     rewritten_data_files_count int Number of data which were re-written by this command   added_data_files_count int Number of new data files which were written by this command    Examples #  Rewrite the data files in table db.sample using the default rewrite algorithm of bin-packing to combine small files and also split large files according to the default write size of the table.\nCALL catalog_name.system.rewrite_data_files(\u0026#39;db.sample\u0026#39;) Rewrite the data files in table db.sample by sorting all the data on id and name using the same defaults as bin-pack to determine which files to rewrite.\nCALL catalog_name.system.rewrite_data_files(table =\u0026gt; \u0026#39;db.sample\u0026#39;, strategy =\u0026gt; \u0026#39;sort\u0026#39;, sort_order =\u0026gt; \u0026#39;id DESC NULLS LAST,name ASC NULLS FIRST\u0026#39;) Rewrite the data files in table db.sample using bin-pack strategy in any partition where more than 2 or more files need to be rewritten.\nCALL catalog_name.system.rewrite_data_files(table =\u0026gt; \u0026#39;db.sample\u0026#39;, options =\u0026gt; map(\u0026#39;min-input-files\u0026#39;,\u0026#39;2\u0026#39;)) Rewrite the data files in table db.sample and select the files that may contain data matching the filter (id = 3 and name = \u0026ldquo;foo\u0026rdquo;) to be rewritten.\nCALL catalog_name.system.rewrite_data_files(table =\u0026gt; \u0026#39;db.sample\u0026#39;, where =\u0026gt; \u0026#39;id = 3 and name = \u0026#34;foo\u0026#34;\u0026#39;) rewrite_manifests #  Rewrite manifests for a table to optimize scan planning.\nData files in manifests are sorted by fields in the partition spec. This procedure runs in parallel using a Spark job.\nSee the RewriteManifestsAction Javadoc to see more configuration options.\nThis procedure invalidates all cached Spark plans that reference the affected table.  Usage #     Argument Name Required? Type Description     table ✔️ string Name of the table to update   use_caching ️ boolean Use Spark caching during operation (defaults to true)    Output #     Output Name Type Description     rewritten_manifests_count int Number of manifests which were re-written by this command   added_mainfests_count int Number of new manifest files which were written by this command    Examples #  Rewrite the manifests in table db.sample and align manifest files with table partitioning.\nCALL catalog_name.system.rewrite_manifests(\u0026#39;db.sample\u0026#39;) Rewrite the manifests in table db.sample and disable the use of Spark caching. This could be done to avoid memory issues on executors.\nCALL catalog_name.system.rewrite_manifests(\u0026#39;db.sample\u0026#39;, false) Table migration #  The snapshot and migrate procedures help test and migrate existing Hive or Spark tables to Iceberg.\nsnapshot #  Create a light-weight temporary copy of a table for testing, without changing the source table.\nThe newly created table can be changed or written to without affecting the source table, but the snapshot uses the original table\u0026rsquo;s data files.\nWhen inserts or overwrites run on the snapshot, new files are placed in the snapshot table\u0026rsquo;s location rather than the original table location.\nWhen finished testing a snapshot table, clean it up by running DROP TABLE.\nBecause tables created by snapshot are not the sole owners of their data files, they are prohibited from actions like expire_snapshots which would physically delete data files. Iceberg deletes, which only effect metadata, are still allowed. In addition, any operations which affect the original data files will disrupt the Snapshot\u0026rsquo;s integrity. DELETE statements executed against the original Hive table will remove original data files and the snapshot table will no longer be able to access them.  See migrate to replace an existing table with an Iceberg table.\nUsage #     Argument Name Required? Type Description     source_table ✔️ string Name of the table to snapshot   table ✔️ string Name of the new Iceberg table to create   location  string Table location for the new table (delegated to the catalog by default)   properties ️ map\u0026lt;string, string\u0026gt; Properties to add to the newly created table    Output #     Output Name Type Description     imported_files_count long Number of files added to the new table    Examples #  Make an isolated Iceberg table which references table db.sample named db.snap at the catalog\u0026rsquo;s default location for db.snap.\nCALL catalog_name.system.snapshot(\u0026#39;db.sample\u0026#39;, \u0026#39;db.snap\u0026#39;) Migrate an isolated Iceberg table which references table db.sample named db.snap at a manually specified location /tmp/temptable/.\nCALL catalog_name.system.snapshot(\u0026#39;db.sample\u0026#39;, \u0026#39;db.snap\u0026#39;, \u0026#39;/tmp/temptable/\u0026#39;) migrate #  Replace a table with an Iceberg table, loaded with the source\u0026rsquo;s data files.\nTable schema, partitioning, properties, and location will be copied from the source table.\nMigrate will fail if any table partition uses an unsupported format. Supported formats are Avro, Parquet, and ORC. Existing data files are added to the Iceberg table\u0026rsquo;s metadata and can be read using a name-to-id mapping created from the original table schema.\nTo leave the original table intact while testing, use snapshot to create new temporary table that shares source data files and schema.\nUsage #     Argument Name Required? Type Description     table ✔️ string Name of the table to migrate   properties ️ map\u0026lt;string, string\u0026gt; Properties for the new Iceberg table    Output #     Output Name Type Description     migrated_files_count long Number of files appended to the Iceberg table    Examples #  Migrate the table db.sample in Spark\u0026rsquo;s default catalog to an Iceberg table and add a property \u0026lsquo;foo\u0026rsquo; set to \u0026lsquo;bar\u0026rsquo;:\nCALL catalog_name.system.migrate(\u0026#39;spark_catalog.db.sample\u0026#39;, map(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;)) Migrate db.sample in the current catalog to an Iceberg table without adding any additional properties:\nCALL catalog_name.system.migrate(\u0026#39;db.sample\u0026#39;) add_files #  Attempts to directly add files from a Hive or file based table into a given Iceberg table. Unlike migrate or snapshot, add_files can import files from a specific partition or partitions and does not create a new Iceberg table. This command will create metadata for the new files and will not move them. This procedure will not analyze the schema of the files to determine if they actually match the schema of the Iceberg table. Upon completion, the Iceberg table will then treat these files as if they are part of the set of files owned by Iceberg. This means any subsequent expire_snapshot calls will be able to physically delete the added files. This method should not be used if migrate or snapshot are possible.\nUsage #     Argument Name Required? Type Description     table ✔️ string Table which will have files added to   source_table ✔️ string Table where files should come from, paths are also possible in the form of `file_format`.`path`   partition_filter ️ map\u0026lt;string, string\u0026gt; A map of partitions in the source table to import from    Warning : Schema is not validated, adding files with different schema to the Iceberg table will cause issues.\nWarning : Files added by this method can be physically deleted by Iceberg operations\nExamples #  Add the files from table db.src_table, a Hive or Spark table registered in the session Catalog, to Iceberg table db.tbl. Only add files that exist within partitions where part_col_1 is equal to A.\nCALL spark_catalog.system.add_files( table =\u0026gt; \u0026#39;db.tbl\u0026#39;, source_table =\u0026gt; \u0026#39;db.src_tbl\u0026#39;, partition_filter =\u0026gt; map(\u0026#39;part_col_1\u0026#39;, \u0026#39;A\u0026#39;) ) Add files from a parquet file based table at location path/to/table to the Iceberg table db.tbl. Add all files regardless of what partition they belong to.\nCALL spark_catalog.system.add_files( table =\u0026gt; \u0026#39;db.tbl\u0026#39;, source_table =\u0026gt; \u0026#39;`parquet`.`path/to/table`\u0026#39; ) Metadata information #  ancestors_of #  Report the live snapshot IDs of parents of a specified snapshot\nUsage #     Argument Name Required? Type Description     table ✔️ string Name of the table to report live snapshot IDs   snapshot_id ️ long Use a specified snapshot to get the live snapshot IDs of parents     tip : Using snapshot_id\nGiven snapshots history with roll back to B and addition of C' -\u0026gt; D'\nA -\u0026gt; B - \u0026gt; C -\u0026gt; D \\ -\u0026gt; C\u0026#39; -\u0026gt; (D\u0026#39;) Not specifying the snapshot ID would return A -\u0026gt; B -\u0026gt; C' -\u0026gt; D', while providing the snapshot ID of D as an argument would return A-\u0026gt; B -\u0026gt; C -\u0026gt; D\n Output #     Output Name Type Description     snapshot_id long the ancestor snapshot id   timestamp long snapshot creation time    Examples #  Get all the snapshot ancestors of current snapshots(default)\nCALL spark_catalog.system.ancestors_of(\u0026#39;db.tbl\u0026#39;) Get all the snapshot ancestors by a particular snapshot\nCALL spark_catalog.system.ancestors_of(\u0026#39;db.tbl\u0026#39;, 1) CALL spark_catalog.system.ancestors_of(snapshot_id =\u0026gt; 1, table =\u0026gt; \u0026#39;db.tbl\u0026#39;) "},{"id":33,"href":"/docs/0.13.0/spark-queries/","title":"Queries","section":"Spark","content":"Spark Queries #  To use Iceberg in Spark, first configure Spark catalogs.\nIceberg uses Apache Spark\u0026rsquo;s DataSourceV2 API for data source and catalog implementations. Spark DSv2 is an evolving API with different levels of support in Spark versions:\n   Feature support Spark 3.0 Spark 2.4 Notes     SELECT ✔️     DataFrame reads ✔️ ✔️    Metadata table SELECT ✔️     History metadata table ✔️ ✔️    Snapshots metadata table ✔️ ✔️    Files metadata table ✔️ ✔️    Manifests metadata table ✔️ ✔️     Querying with SQL #  In Spark 3, tables use identifiers that include a catalog name.\nSELECT * FROM prod.db.table -- catalog: prod, namespace: db, table: table Metadata tables, like history and snapshots, can use the Iceberg table name as a namespace.\nFor example, to read from the files metadata table for prod.db.table, run:\nSELECT * FROM prod.db.table.files    content file_path file_format spec_id partition record_count file_size_in_bytes column_sizes value_counts null_value_counts nan_value_counts lower_bounds upper_bounds key_metadata split_offsets equality_ids sort_order_id     0 s3:/\u0026hellip;/table/data/00000-3-8d6d60e8-d427-4809-bcf0-f5d45a4aad96.parquet PARQUET 0 {1999-01-01, 01} 1 597 [1 -\u0026gt; 90, 2 -\u0026gt; 62] [1 -\u0026gt; 1, 2 -\u0026gt; 1] [1 -\u0026gt; 0, 2 -\u0026gt; 0] [] [1 -\u0026gt; , 2 -\u0026gt; c] [1 -\u0026gt; , 2 -\u0026gt; c] null [4] null null   0 s3:/\u0026hellip;/table/data/00001-4-8d6d60e8-d427-4809-bcf0-f5d45a4aad96.parquet PARQUET 0 {1999-01-01, 02} 1 597 [1 -\u0026gt; 90, 2 -\u0026gt; 62] [1 -\u0026gt; 1, 2 -\u0026gt; 1] [1 -\u0026gt; 0, 2 -\u0026gt; 0] [] [1 -\u0026gt; , 2 -\u0026gt; b] [1 -\u0026gt; , 2 -\u0026gt; b] null [4] null null   0 s3:/\u0026hellip;/table/data/00002-5-8d6d60e8-d427-4809-bcf0-f5d45a4aad96.parquet PARQUET 0 {1999-01-01, 03} 1 597 [1 -\u0026gt; 90, 2 -\u0026gt; 62] [1 -\u0026gt; 1, 2 -\u0026gt; 1] [1 -\u0026gt; 0, 2 -\u0026gt; 0] [] [1 -\u0026gt; , 2 -\u0026gt; a] [1 -\u0026gt; , 2 -\u0026gt; a] null [4] null null    Querying with DataFrames #  To load a table as a DataFrame, use table:\nval df = spark.table(\u0026#34;prod.db.table\u0026#34;) Catalogs with DataFrameReader #  Iceberg 0.11.0 adds multi-catalog support to DataFrameReader in both Spark 3.x and 2.4.\nPaths and table names can be loaded with Spark\u0026rsquo;s DataFrameReader interface. How tables are loaded depends on how the identifier is specified. When using spark.read.format(\u0026quot;iceberg\u0026quot;).path(table) or spark.table(table) the table variable can take a number of forms as listed below:\n file:/path/to/table: loads a HadoopTable at given path tablename: loads currentCatalog.currentNamespace.tablename catalog.tablename: loads tablename from the specified catalog. namespace.tablename: loads namespace.tablename from current catalog catalog.namespace.tablename: loads namespace.tablename from the specified catalog. namespace1.namespace2.tablename: loads namespace1.namespace2.tablename from current catalog  The above list is in order of priority. For example: a matching catalog will take priority over any namespace resolution.\nTime travel #  To select a specific table snapshot or the snapshot at some time, Iceberg supports two Spark read options:\n snapshot-id selects a specific table snapshot as-of-timestamp selects the current snapshot at a timestamp, in milliseconds  // time travel to October 26, 1986 at 01:21:00 spark.read .option(\u0026#34;as-of-timestamp\u0026#34;, \u0026#34;499162860000\u0026#34;) .format(\u0026#34;iceberg\u0026#34;) .load(\u0026#34;path/to/table\u0026#34;) // time travel to snapshot with ID 10963874102873L spark.read .option(\u0026#34;snapshot-id\u0026#34;, 10963874102873L) .format(\u0026#34;iceberg\u0026#34;) .load(\u0026#34;path/to/table\u0026#34;) Spark does not currently support using option with table in DataFrameReader commands. All options will be silently ignored. Do not use table when attempting to time-travel or use other options. Options will be supported with table in Spark 3.1 - SPARK-32592.  Time travel is not yet supported by Spark\u0026rsquo;s SQL syntax.\nIncremental read #  To read appended data incrementally, use:\n start-snapshot-id Start snapshot ID used in incremental scans (exclusive). end-snapshot-id End snapshot ID used in incremental scans (inclusive). This is optional. Omitting it will default to the current snapshot.  // get the data added after start-snapshot-id (10963874102873L) until end-snapshot-id (63874143573109L) spark.read() .format(\u0026#34;iceberg\u0026#34;) .option(\u0026#34;start-snapshot-id\u0026#34;, \u0026#34;10963874102873\u0026#34;) .option(\u0026#34;end-snapshot-id\u0026#34;, \u0026#34;63874143573109\u0026#34;) .load(\u0026#34;path/to/table\u0026#34;) Currently gets only the data from append operation. Cannot support replace, overwrite, delete operations. Incremental read works with both V1 and V2 format-version. Incremental read is not supported by Spark\u0026rsquo;s SQL syntax.  Spark 2.4 #  Spark 2.4 requires using the DataFrame reader with iceberg as a format, because 2.4 does not support direct SQL queries:\n// named metastore table spark.read.format(\u0026#34;iceberg\u0026#34;).load(\u0026#34;catalog.db.table\u0026#34;) // Hadoop path table spark.read.format(\u0026#34;iceberg\u0026#34;).load(\u0026#34;hdfs://nn:8020/path/to/table\u0026#34;) Spark 2.4 with SQL #  To run SQL SELECT statements on Iceberg tables in 2.4, register the DataFrame as a temporary table:\nval df = spark.read.format(\u0026#34;iceberg\u0026#34;).load(\u0026#34;db.table\u0026#34;) df.createOrReplaceTempView(\u0026#34;table\u0026#34;) spark.sql(\u0026#34;\u0026#34;\u0026#34;select count(1) from table\u0026#34;\u0026#34;\u0026#34;).show() Inspecting tables #  To inspect a table\u0026rsquo;s history, snapshots, and other metadata, Iceberg supports metadata tables.\nMetadata tables are identified by adding the metadata table name after the original table name. For example, history for db.table is read using db.table.history.\nAs of Spark 3.0, the format of the table name for inspection (catalog.database.table.metadata) doesn\u0026rsquo;t work with Spark\u0026rsquo;s default catalog (spark_catalog). If you\u0026rsquo;ve replaced the default catalog, you may want to use DataFrameReader API to inspect the table.  History #  To show table history, run:\nSELECT * FROM prod.db.table.history +-------------------------+---------------------+---------------------+---------------------+ | made_current_at | snapshot_id | parent_id | is_current_ancestor | +-------------------------+---------------------+---------------------+---------------------+ | 2019-02-08 03:29:51.215 | 5781947118336215154 | NULL | true | | 2019-02-08 03:47:55.948 | 5179299526185056830 | 5781947118336215154 | true | | 2019-02-09 16:24:30.13 | 296410040247533544 | 5179299526185056830 | false | | 2019-02-09 16:32:47.336 | 2999875608062437330 | 5179299526185056830 | true | | 2019-02-09 19:42:03.919 | 8924558786060583479 | 2999875608062437330 | true | | 2019-02-09 19:49:16.343 | 6536733823181975045 | 8924558786060583479 | true | +-------------------------+---------------------+---------------------+---------------------+ This shows a commit that was rolled back. The example has two snapshots with the same parent, and one is not an ancestor of the current table state.  Snapshots #  To show the valid snapshots for a table, run:\nSELECT * FROM prod.db.table.snapshots +-------------------------+----------------+-----------+-----------+----------------------------------------------------+-------------------------------------------------------+ | committed_at | snapshot_id | parent_id | operation | manifest_list | summary | +-------------------------+----------------+-----------+-----------+----------------------------------------------------+-------------------------------------------------------+ | 2019-02-08 03:29:51.215 | 57897183625154 | null | append | s3://.../table/metadata/snap-57897183625154-1.avro | { added-records -\u0026gt; 2478404, total-records -\u0026gt; 2478404, | | | | | | | added-data-files -\u0026gt; 438, total-data-files -\u0026gt; 438, | | | | | | | spark.app.id -\u0026gt; application_1520379288616_155055 } | | ... | ... | ... | ... | ... | ... | +-------------------------+----------------+-----------+-----------+----------------------------------------------------+-------------------------------------------------------+ You can also join snapshots to table history. For example, this query will show table history, with the application ID that wrote each snapshot:\nselect h.made_current_at, s.operation, h.snapshot_id, h.is_current_ancestor, s.summary[\u0026#39;spark.app.id\u0026#39;] from prod.db.table.history h join prod.db.table.snapshots s on h.snapshot_id = s.snapshot_id order by made_current_at +-------------------------+-----------+----------------+---------------------+----------------------------------+ | made_current_at | operation | snapshot_id | is_current_ancestor | summary[spark.app.id] | +-------------------------+-----------+----------------+---------------------+----------------------------------+ | 2019-02-08 03:29:51.215 | append | 57897183625154 | true | application_1520379288616_155055 | | 2019-02-09 16:24:30.13 | delete | 29641004024753 | false | application_1520379288616_151109 | | 2019-02-09 16:32:47.336 | append | 57897183625154 | true | application_1520379288616_155055 | | 2019-02-08 03:47:55.948 | overwrite | 51792995261850 | true | application_1520379288616_152431 | +-------------------------+-----------+----------------+---------------------+----------------------------------+ Files #  To show a table\u0026rsquo;s data files and each file\u0026rsquo;s metadata, run:\nSELECT * FROM prod.db.table.files    content file_path file_format spec_id partition record_count file_size_in_bytes column_sizes value_counts null_value_counts nan_value_counts lower_bounds upper_bounds key_metadata split_offsets equality_ids sort_order_id     0 s3:/\u0026hellip;/table/data/00000-3-8d6d60e8-d427-4809-bcf0-f5d45a4aad96.parquet PARQUET 0 {1999-01-01, 01} 1 597 [1 -\u0026gt; 90, 2 -\u0026gt; 62] [1 -\u0026gt; 1, 2 -\u0026gt; 1] [1 -\u0026gt; 0, 2 -\u0026gt; 0] [] [1 -\u0026gt; , 2 -\u0026gt; c] [1 -\u0026gt; , 2 -\u0026gt; c] null [4] null null   0 s3:/\u0026hellip;/table/data/00001-4-8d6d60e8-d427-4809-bcf0-f5d45a4aad96.parquet PARQUET 0 {1999-01-01, 02} 1 597 [1 -\u0026gt; 90, 2 -\u0026gt; 62] [1 -\u0026gt; 1, 2 -\u0026gt; 1] [1 -\u0026gt; 0, 2 -\u0026gt; 0] [] [1 -\u0026gt; , 2 -\u0026gt; b] [1 -\u0026gt; , 2 -\u0026gt; b] null [4] null null   0 s3:/\u0026hellip;/table/data/00002-5-8d6d60e8-d427-4809-bcf0-f5d45a4aad96.parquet PARQUET 0 {1999-01-01, 03} 1 597 [1 -\u0026gt; 90, 2 -\u0026gt; 62] [1 -\u0026gt; 1, 2 -\u0026gt; 1] [1 -\u0026gt; 0, 2 -\u0026gt; 0] [] [1 -\u0026gt; , 2 -\u0026gt; a] [1 -\u0026gt; , 2 -\u0026gt; a] null [4] null null    Manifests #  To show a table\u0026rsquo;s file manifests and each file\u0026rsquo;s metadata, run:\nSELECT * FROM prod.db.table.manifests +----------------------------------------------------------------------+--------+-------------------+---------------------+------------------------+---------------------------+--------------------------+--------------------------------------+ | path | length | partition_spec_id | added_snapshot_id | added_data_files_count | existing_data_files_count | deleted_data_files_count | partition_summaries | +----------------------------------------------------------------------+--------+-------------------+---------------------+------------------------+---------------------------+--------------------------+--------------------------------------+ | s3://.../table/metadata/45b5290b-ee61-4788-b324-b1e2735c0e10-m0.avro | 4479 | 0 | 6668963634911763636 | 8 | 0 | 0 | [[false,null,2019-05-13,2019-05-15]] | +----------------------------------------------------------------------+--------+-------------------+---------------------+------------------------+---------------------------+--------------------------+--------------------------------------+ Note:\n Fields within partition_summaries column of the manifests table correspond to field_summary structs within manifest list, with the following order:  contains_null contains_nan lower_bound upper_bound   contains_nan could return null, which indicates that this information is not available from files' metadata. This usually occurs when reading from V1 table, where contains_nan is not populated.  Inspecting with DataFrames #  Metadata tables can be loaded in Spark 2.4 or Spark 3 using the DataFrameReader API:\n// named metastore table spark.read.format(\u0026#34;iceberg\u0026#34;).load(\u0026#34;db.table.files\u0026#34;).show(truncate = false) // Hadoop path table spark.read.format(\u0026#34;iceberg\u0026#34;).load(\u0026#34;hdfs://nn:8020/path/to/table#files\u0026#34;).show(truncate = false) "},{"id":34,"href":"/docs/0.13.0/spark-structured-streaming/","title":"Structured Streaming","section":"Spark","content":"Spark Structured Streaming #  Iceberg uses Apache Spark\u0026rsquo;s DataSourceV2 API for data source and catalog implementations. Spark DSv2 is an evolving API with different levels of support in Spark versions.\nAs of Spark 3.0, DataFrame reads and writes are supported.\n   Feature support Spark 3.0 Spark 2.4 Notes     DataFrame write ✔ ✔     Streaming Reads #  Iceberg supports processing incremental data in spark structured streaming jobs which starts from a historical timestamp:\nval df = spark.readStream .format(\u0026#34;iceberg\u0026#34;) .option(\u0026#34;stream-from-timestamp\u0026#34;, Long.toString(streamStartTimestamp)) .load(\u0026#34;database.table_name\u0026#34;) Iceberg only supports reading data from append snapshots. Overwrite snapshots cannot be processed and will cause an exception. Similarly, delete snapshots will cause an exception by default, but deletes may be ignored by setting streaming-skip-delete-snapshots=true.  Streaming Writes #  To write values from streaming query to Iceberg table, use DataStreamWriter:\nval tableIdentifier: String = ... data.writeStream .format(\u0026#34;iceberg\u0026#34;) .outputMode(\u0026#34;append\u0026#34;) .trigger(Trigger.ProcessingTime(1, TimeUnit.MINUTES)) .option(\u0026#34;path\u0026#34;, tableIdentifier) .option(\u0026#34;checkpointLocation\u0026#34;, checkpointPath) .start() The tableIdentifier can be:\n The fully-qualified path to a HDFS table, like hdfs://nn:8020/path/to/table A table name if the table is tracked by a catalog, like database.table_name  Iceberg doesn\u0026rsquo;t support \u0026ldquo;continuous processing\u0026rdquo;, as it doesn\u0026rsquo;t provide the interface to \u0026ldquo;commit\u0026rdquo; the output.\nIceberg supports append and complete output modes:\n append: appends the rows of every micro-batch to the table complete: replaces the table contents every micro-batch  The table should be created in prior to start the streaming query. Refer SQL create table on Spark page to see how to create the Iceberg table.\nWriting against partitioned table #  Iceberg requires the data to be sorted according to the partition spec per task (Spark partition) in prior to write against partitioned table. For batch queries you\u0026rsquo;re encouraged to do explicit sort to fulfill the requirement (see here), but the approach would bring additional latency as repartition and sort are considered as heavy operations for streaming workload. To avoid additional latency, you can enable fanout writer to eliminate the requirement.\nval tableIdentifier: String = ... data.writeStream .format(\u0026#34;iceberg\u0026#34;) .outputMode(\u0026#34;append\u0026#34;) .trigger(Trigger.ProcessingTime(1, TimeUnit.MINUTES)) .option(\u0026#34;path\u0026#34;, tableIdentifier) .option(\u0026#34;fanout-enabled\u0026#34;, \u0026#34;true\u0026#34;) .option(\u0026#34;checkpointLocation\u0026#34;, checkpointPath) .start() Fanout writer opens the files per partition value and doesn\u0026rsquo;t close these files till write task is finished. This functionality is discouraged for batch query, as explicit sort against output rows isn\u0026rsquo;t expensive for batch workload.\nMaintenance for streaming tables #  Streaming queries can create new table versions quickly, which creates lots of table metadata to track those versions. Maintaining metadata by tuning the rate of commits, expiring old snapshots, and automatically cleaning up metadata files is highly recommended.\nTune the rate of commits #  Having high rate of commits would produce lots of data files, manifests, and snapshots which leads the table hard to maintain. We encourage having trigger interval 1 minute at minimum, and increase the interval if needed.\nThe triggers section in Structured Streaming Programming Guide documents how to configure the interval.\nExpire old snapshots #  Each micro-batch written to a table produces a new snapshot, which are tracked in table metadata until they are expired to remove the metadata and any data files that are no longer needed. Snapshots accumulate quickly with frequent commits, so it is highly recommended that tables written by streaming queries are regularly maintained.\nCompacting data files #  The amount of data written in a micro batch is typically small, which can cause the table metadata to track lots of small files. Compacting small files into larger files reduces the metadata needed by the table, and increases query efficiency.\nRewrite manifests #  To optimize write latency on streaming workload, Iceberg may write the new snapshot with a \u0026ldquo;fast\u0026rdquo; append that does not automatically compact manifests. This could lead lots of small manifest files. Manifests can be rewritten to optimize queries and to compact.\n"},{"id":35,"href":"/docs/0.13.0/spark-writes/","title":"Writes","section":"Spark","content":"Spark Writes #  To use Iceberg in Spark, first configure Spark catalogs.\nSome plans are only available when using Iceberg SQL extensions in Spark 3.x.\nIceberg uses Apache Spark\u0026rsquo;s DataSourceV2 API for data source and catalog implementations. Spark DSv2 is an evolving API with different levels of support in Spark versions:\n   Feature support Spark 3.0 Spark 2.4 Notes     SQL insert into ✔️     SQL merge into ✔️  ⚠ Requires Iceberg Spark extensions   SQL insert overwrite ✔️     SQL delete from ✔️  ⚠ Row-level delete requires Spark extensions   SQL update ✔️  ⚠ Requires Iceberg Spark extensions   DataFrame append ✔️ ✔️    DataFrame overwrite ✔️ ✔️ ⚠ Behavior changed in Spark 3.0   DataFrame CTAS and RTAS ✔️      Writing with SQL #  Spark 3 supports SQL INSERT INTO, MERGE INTO, and INSERT OVERWRITE, as well as the new DataFrameWriterV2 API.\nINSERT INTO #  To append new data to a table, use INSERT INTO.\nINSERT INTO prod.db.table VALUES (1, \u0026#39;a\u0026#39;), (2, \u0026#39;b\u0026#39;) INSERT INTO prod.db.table SELECT ... MERGE INTO #  Spark 3 added support for MERGE INTO queries that can express row-level updates.\nIceberg supports MERGE INTO by rewriting data files that contain rows that need to be updated in an overwrite commit.\nMERGE INTO is recommended instead of INSERT OVERWRITE because Iceberg can replace only the affected data files, and because the data overwritten by a dynamic overwrite may change if the table\u0026rsquo;s partitioning changes.\nMERGE INTO syntax #  MERGE INTO updates a table, called the target table, using a set of updates from another query, called the source. The update for a row in the target table is found using the ON clause that is like a join condition.\nMERGE INTO prod.db.target t -- a target table USING (SELECT ...) s -- the source updates ON t.id = s.id -- condition to find updates for target rows WHEN ... -- updates Updates to rows in the target table are listed using WHEN MATCHED ... THEN .... Multiple MATCHED clauses can be added with conditions that determine when each match should be applied. The first matching expression is used.\nWHEN MATCHED AND s.op = \u0026#39;delete\u0026#39; THEN DELETE WHEN MATCHED AND t.count IS NULL AND s.op = \u0026#39;increment\u0026#39; THEN UPDATE SET t.count = 0 WHEN MATCHED AND s.op = \u0026#39;increment\u0026#39; THEN UPDATE SET t.count = t.count + 1 Source rows (updates) that do not match can be inserted:\nWHEN NOT MATCHED THEN INSERT * Inserts also support additional conditions:\nWHEN NOT MATCHED AND s.event_time \u0026gt; still_valid_threshold THEN INSERT (id, count) VALUES (s.id, 1) Only one record in the source data can update any given row of the target table, or else an error will be thrown.\nINSERT OVERWRITE #  INSERT OVERWRITE can replace data in the table with the result of a query. Overwrites are atomic operations for Iceberg tables.\nThe partitions that will be replaced by INSERT OVERWRITE depends on Spark\u0026rsquo;s partition overwrite mode and the partitioning of a table. MERGE INTO can rewrite only affected data files and has more easily understood behavior, so it is recommended instead of INSERT OVERWRITE.\nSpark 3.0.0 has a correctness bug that affects dynamic INSERT OVERWRITE with hidden partitioning, [SPARK-32168][spark-32168]. For tables with hidden partitions, make sure you use Spark 3.0.1.  Overwrite behavior #  Spark\u0026rsquo;s default overwrite mode is static, but dynamic overwrite mode is recommended when writing to Iceberg tables. Static overwrite mode determines which partitions to overwrite in a table by converting the PARTITION clause to a filter, but the PARTITION clause can only reference table columns.\nDynamic overwrite mode is configured by setting spark.sql.sources.partitionOverwriteMode=dynamic.\nTo demonstrate the behavior of dynamic and static overwrites, consider a logs table defined by the following DDL:\nCREATE TABLE prod.my_app.logs ( uuid string NOT NULL, level string NOT NULL, ts timestamp NOT NULL, message string) USING iceberg PARTITIONED BY (level, hours(ts)) Dynamic overwrite #  When Spark\u0026rsquo;s overwrite mode is dynamic, partitions that have rows produced by the SELECT query will be replaced.\nFor example, this query removes duplicate log events from the example logs table.\nINSERT OVERWRITE prod.my_app.logs SELECT uuid, first(level), first(ts), first(message) FROM prod.my_app.logs WHERE cast(ts as date) = \u0026#39;2020-07-01\u0026#39; GROUP BY uuid In dynamic mode, this will replace any partition with rows in the SELECT result. Because the date of all rows is restricted to 1 July, only hours of that day will be replaced.\nStatic overwrite #  When Spark\u0026rsquo;s overwrite mode is static, the PARTITION clause is converted to a filter that is used to delete from the table. If the PARTITION clause is omitted, all partitions will be replaced.\nBecause there is no PARTITION clause in the query above, it will drop all existing rows in the table when run in static mode, but will only write the logs from 1 July.\nTo overwrite just the partitions that were loaded, add a PARTITION clause that aligns with the SELECT query filter:\nINSERT OVERWRITE prod.my_app.logs PARTITION (level = \u0026#39;INFO\u0026#39;) SELECT uuid, first(level), first(ts), first(message) FROM prod.my_app.logs WHERE level = \u0026#39;INFO\u0026#39; GROUP BY uuid Note that this mode cannot replace hourly partitions like the dynamic example query because the PARTITION clause can only reference table columns, not hidden partitions.\nDELETE FROM #  Spark 3 added support for DELETE FROM queries to remove data from tables.\nDelete queries accept a filter to match rows to delete.\nDELETE FROM prod.db.table WHERE ts \u0026gt;= \u0026#39;2020-05-01 00:00:00\u0026#39; and ts \u0026lt; \u0026#39;2020-06-01 00:00:00\u0026#39; DELETE FROM prod.db.all_events WHERE session_time \u0026lt; (SELECT min(session_time) FROM prod.db.good_events) DELETE FROM prod.db.orders AS t1 WHERE EXISTS (SELECT oid FROM prod.db.returned_orders WHERE t1.oid = oid) If the delete filter matches entire partitions of the table, Iceberg will perform a metadata-only delete. If the filter matches individual rows of a table, then Iceberg will rewrite only the affected data files.\nUPDATE #  Spark 3.1 added support for UPDATE queries that update matching rows in tables.\nUpdate queries accept a filter to match rows to update.\nUPDATE prod.db.table SET c1 = \u0026#39;update_c1\u0026#39;, c2 = \u0026#39;update_c2\u0026#39; WHERE ts \u0026gt;= \u0026#39;2020-05-01 00:00:00\u0026#39; and ts \u0026lt; \u0026#39;2020-06-01 00:00:00\u0026#39; UPDATE prod.db.all_events SET session_time = 0, ignored = true WHERE session_time \u0026lt; (SELECT min(session_time) FROM prod.db.good_events) UPDATE prod.db.orders AS t1 SET order_status = \u0026#39;returned\u0026#39; WHERE EXISTS (SELECT oid FROM prod.db.returned_orders WHERE t1.oid = oid) For more complex row-level updates based on incoming data, see the section on MERGE INTO.\nWriting with DataFrames #  Spark 3 introduced the new DataFrameWriterV2 API for writing to tables using data frames. The v2 API is recommended for several reasons:\n CTAS, RTAS, and overwrite by filter are supported All operations consistently write columns to a table by name Hidden partition expressions are supported in partitionedBy Overwrite behavior is explicit, either dynamic or by a user-supplied filter The behavior of each operation corresponds to SQL statements  df.writeTo(t).create() is equivalent to CREATE TABLE AS SELECT df.writeTo(t).replace() is equivalent to REPLACE TABLE AS SELECT df.writeTo(t).append() is equivalent to INSERT INTO df.writeTo(t).overwritePartitions() is equivalent to dynamic INSERT OVERWRITE    The v1 DataFrame write API is still supported, but is not recommended.\nWhen writing with the v1 DataFrame API in Spark 3, use saveAsTable or insertInto to load tables with a catalog. Using format(\u0026quot;iceberg\u0026quot;) loads an isolated table reference that will not automatically refresh tables used by queries.  Appending data #  To append a dataframe to an Iceberg table, use append:\nval data: DataFrame = ... data.writeTo(\u0026#34;prod.db.table\u0026#34;).append() Spark 2.4 #  In Spark 2.4, use the v1 API with append mode and iceberg format:\ndata.write .format(\u0026#34;iceberg\u0026#34;) .mode(\u0026#34;append\u0026#34;) .save(\u0026#34;db.table\u0026#34;) Overwriting data #  To overwrite partitions dynamically, use overwritePartitions():\nval data: DataFrame = ... data.writeTo(\u0026#34;prod.db.table\u0026#34;).overwritePartitions() To explicitly overwrite partitions, use overwrite to supply a filter:\ndata.writeTo(\u0026#34;prod.db.table\u0026#34;).overwrite($\u0026#34;level\u0026#34; === \u0026#34;INFO\u0026#34;) Spark 2.4 #  In Spark 2.4, overwrite values in an Iceberg table with overwrite mode and iceberg format:\ndata.write .format(\u0026#34;iceberg\u0026#34;) .mode(\u0026#34;overwrite\u0026#34;) .save(\u0026#34;db.table\u0026#34;) The behavior of overwrite mode changed between Spark 2.4 and Spark 3.  The behavior of DataFrameWriter overwrite mode was undefined in Spark 2.4, but is required to overwrite the entire table in Spark 3. Because of this new requirement, the Iceberg source\u0026rsquo;s behavior changed in Spark 3. In Spark 2.4, the behavior was to dynamically overwrite partitions. To use the Spark 2.4 behavior, add option overwrite-mode=dynamic.\nCreating tables #  To run a CTAS or RTAS, use create, replace, or createOrReplace operations:\nval data: DataFrame = ... data.writeTo(\u0026#34;prod.db.table\u0026#34;).create() Create and replace operations support table configuration methods, like partitionedBy and tableProperty:\ndata.writeTo(\u0026#34;prod.db.table\u0026#34;) .tableProperty(\u0026#34;write.format.default\u0026#34;, \u0026#34;orc\u0026#34;) .partitionBy($\u0026#34;level\u0026#34;, days($\u0026#34;ts\u0026#34;)) .createOrReplace() Writing to partitioned tables #  Iceberg requires the data to be sorted according to the partition spec per task (Spark partition) in prior to write against partitioned table. This applies both Writing with SQL and Writing with DataFrames.\nExplicit sort is necessary because Spark doesn\u0026rsquo;t allow Iceberg to request a sort before writing as of Spark 3.0. SPARK-23889 is filed to enable Iceberg to require specific distribution \u0026amp; sort order to Spark.  Both global sort (orderBy/sort) and local sort (sortWithinPartitions) work for the requirement.  Let\u0026rsquo;s go through writing the data against below sample table:\nCREATE TABLE prod.db.sample ( id bigint, data string, category string, ts timestamp) USING iceberg PARTITIONED BY (days(ts), category) To write data to the sample table, your data needs to be sorted by days(ts), category.\nIf you\u0026rsquo;re inserting data with SQL statement, you can use ORDER BY to achieve it, like below:\nINSERT INTO prod.db.sample SELECT id, data, category, ts FROM another_table ORDER BY ts, category If you\u0026rsquo;re inserting data with DataFrame, you can use either orderBy/sort to trigger global sort, or sortWithinPartitions to trigger local sort. Local sort for example:\ndata.sortWithinPartitions(\u0026#34;ts\u0026#34;, \u0026#34;category\u0026#34;) .writeTo(\u0026#34;prod.db.sample\u0026#34;) .append() You can simply add the original column to the sort condition for the most partition transformations, except bucket.\nFor bucket partition transformation, you need to register the Iceberg transform function in Spark to specify it during sort.\nLet\u0026rsquo;s go through another sample table having bucket partition:\nCREATE TABLE prod.db.sample ( id bigint, data string, category string, ts timestamp) USING iceberg PARTITIONED BY (bucket(16, id)) You need to register the function to deal with bucket, like below:\nimport org.apache.iceberg.spark.IcebergSpark import org.apache.spark.sql.types.DataTypes IcebergSpark.registerBucketUDF(spark, \u0026#34;iceberg_bucket16\u0026#34;, DataTypes.LongType, 16) Explicit registration of the function is necessary because Spark doesn\u0026rsquo;t allow Iceberg to provide functions. SPARK-27658 is filed to enable Iceberg to provide functions which can be used in query.  Here we just registered the bucket function as iceberg_bucket16, which can be used in sort clause.\nIf you\u0026rsquo;re inserting data with SQL statement, you can use the function like below:\nINSERT INTO prod.db.sample SELECT id, data, category, ts FROM another_table ORDER BY iceberg_bucket16(id) If you\u0026rsquo;re inserting data with DataFrame, you can use the function like below:\ndata.sortWithinPartitions(expr(\u0026#34;iceberg_bucket16(id)\u0026#34;)) .writeTo(\u0026#34;prod.db.sample\u0026#34;) .append() Type compatibility #  Spark and Iceberg support different set of types. Iceberg does the type conversion automatically, but not for all combinations, so you may want to understand the type conversion in Iceberg in prior to design the types of columns in your tables.\nSpark type to Iceberg type #  This type conversion table describes how Spark types are converted to the Iceberg types. The conversion applies on both creating Iceberg table and writing to Iceberg table via Spark.\n   Spark Iceberg Notes     boolean boolean    short integer    byte integer    integer integer    long long    float float    double double    date date    timestamp timestamp with timezone    char string    varchar string    string string    binary binary    decimal decimal    struct struct    array list    map map     The table is based on representing conversion during creating table. In fact, broader supports are applied on write. Here\u0026rsquo;re some points on write:\n Iceberg numeric types (integer, long, float, double, decimal) support promotion during writes. e.g. You can write Spark types short, byte, integer, long to Iceberg type long. You can write to Iceberg fixed type using Spark binary type. Note that assertion on the length will be performed.   Iceberg type to Spark type #  This type conversion table describes how Iceberg types are converted to the Spark types. The conversion applies on reading from Iceberg table via Spark.\n   Iceberg Spark Note     boolean boolean    integer integer    long long    float float    double double    date date    time  Not supported   timestamp with timezone timestamp    timestamp without timezone  Not supported   string string    uuid string    fixed binary    binary binary    decimal decimal    struct struct    list array    map map     "}]